{:title "Holy Dev Newsletter February 2023"
 :hide-from-home? true
 :date "2023-02-01"
 :tags ["newsletter"]}

Welcome to the Holy Dev newsletter, which brings you gems I found on the web, updates from my blog, and a few scattered thoughts. You can get the next one into your mailbox if you link:/me/subscribe[subscribe].

== What is happening
I'am been busy working on the small Fulcro RAD ERP system for a friend. I have leveraged the work to publish a couple of live coding videos:

. https://www.youtube.com/watch?v=CU8T0WeCDGA&list=PLYvJiiE4TAij-7i6O2qFYPkIS8PZnP-lc&index=1[Fulcro live coding: Delete mutation to list of dependants, part 1] - I create a custom mutation that only deletes an entity if nothing depends on it. If there are any dependants then it displays a popup with a list of these entities ... (sorry for the terrible sound, it is better in all future recordings)
. https://www.youtube.com/watch?v=5HLh96MzHEE&list=PLYvJiiE4TAij-7i6O2qFYPkIS8PZnP-lc&index=2&t=9s[Fulcro live coding: Delete mutation to list of dependants, part 2]
. https://www.youtube.com/watch?v=YDeiY0cu5kM[Fulcro live coding 3 - Simplify with UISM] - here I learn how to replace complicated logic in a component and mutations with a UI state machine

I have also created an https://blog.jakubholy.net/tags/newsletter/[archive of all past newsletters] so you can more easily find interesting links you know I have mentioned.

Finally, I am starting a new Fulcro teaching video series with a friend, where we will go from (almost) 0 to a Fulcro app in production. I will keep you posted :-).

== Gems from the world wide web
++++
<p><span>üé• <a href="https://www.youtube.com/watch?v=Mjn92fODdaA&amp;list=WL&amp;index=2">Simpler User Interfaces with Membrane (by Adrian Smith)</a></span><br><span style="white-space: pre-line;">An interesting discussion what a true functional UI programming / framework would look like and what is wrong with essentially all current, non-pure UI frameworks. The key problem is that view functions and event handlers are impure and side-effecting. Instead, views (i.e. components) should return immutable data describing the UI and even handlers should just produce effect / "intent" description as data. Components should be pure functions - only relying on their arguments and producing data. Then they are truly reusable, no matter what framework you use.</span><br><span style="white-space: pre-line;">The talk essentially describes the status quo and design principles behind Membrane, and is very relevant even if you do not care about Membrane, which is only mentioned marginally. It is a UI framework created as an exploration into extremely functional UI, which turned out to be very possible and practical.</span><br><span style="white-space: pre-line;">Note: In the same domain is <a href="https://www.youtube.com/watch?v=cM5e_tJqbT8&amp;list=WL&amp;index=4">Clojure + UI = ‚ù§Ô∏è</a> by Nikita Prokopov, which introduces his <a href="https://github.com/HumbleUI/HumbleUI">Humble UI</a> - a new, practical UI framework for Clojure desktop applications (b/c Java frameworks suck and Electron has its issues....). It is built on Skia, which powers Chrome, Flutter &amp; more. It doesn't try to be functional but, contrary to HTML, provides a simple layout, sane text metrics (i.e. no random, OS-based space around letters), REPL-ability, and truly composable components (such as label, rect, shadow, clickable, hoverable, padding, center, ... that you put together to make a button of your dreams).</span></p><p><span class="link">üëì <a href="https://github.com/discourje/development">discourje/development</a> [clojure, library, async]</span><br><span style="white-space: pre-line;">Automated, runtime correctness analysis for core.async, based on instrumentation and checking of communication against predefined spec. (Can A talk to B? Does the message satisfy a predicate?) It can detect when the wrong processes communicate and a number of cases of deadlocks. There is a ClojureDays 2022 <a href="https://www.youtube.com/watch?v=AB0rLLVej6U&amp;list=WL&amp;index=2">talk introducing the library</a>.</span><br><span style="white-space: pre-line;">Currently it only supports basic blocking read/write operations + timeout, thread, alts!!. I hope it will continue developing, because I missed such a thing multiple times.</span></p><p><span class="link">üëì <a href="https://vector.dev/">Vector</a> [devops, observability]</span><br><span style="white-space: pre-line;">A lightweight, ultra-fast tool for building observability pipelines / getting observability data from sources to sinks - collect logs and metrics from various sources, process them with programmable transforms (structure, sample, aggregate), send to various sinks (S3, Prometheus, ...). Used e.g. by Fly.io. Written in Rust. <a href="https://vector.dev/docs/setup/deployment">Deploy</a> as a <a href="https://vector.dev/docs/setup/deployment/roles/#daemon">daemon</a>, <a href="https://vector.dev/docs/setup/deployment/roles/#sidecar">sidecar</a>, or <a href="https://vector.dev/docs/setup/deployment/roles/#aggregator">aggregator</a>. Created by Datadog.</span></p><p><span class="link">üëì <a href="https://joshcollinsworth.com/blog/self-fulfilling-prophecy-of-react">The self-fulfilling prophecy of React</a> [reactjs, criticism] - <q>The only thing React is better at than other front-end frameworks is being popular. So how long will that self-perpetuating cycle continue?</q></span><br><span style="white-space: pre-line;">A thought-provoking criticism of React. Highlights:</span><br><span style="white-space: pre-line;">React‚Äôs greatness is more in what it meant at the time‚Äîand in what it <em>inspired</em>‚Äîthan what it currently is <em>today</em>. It has aged a lot, and not well - React‚Äôs velocity, and its ceiling, have long lagged behind that of its comparable colleagues.</span><br><span style="white-space: pre-line;">The author compares React with other modern frameworks such as Vue, Svelte, Solid etc. on performance, learning curve (JSX :'( ), bundle size, dev experience, and more.</span></p>
++++

+++--+++

Thank you for reading!

{:title "Holy Dev Newsletter January 2023 & December 2022"
 :hide-from-home? true
 :date "2023-01-31"
 :tags ["newsletter"]}

Welcome to the Holy Dev newsletter, which brings you gems I found on the web, updates from my blog, and a few scattered thoughts. You can get the next one into your mailbox if you link:/me/subscribe[subscribe]. This time it is a double issue because I obviously forgot to publish in December üòÖ.

== What I am thinking about

I have long felt that software development is wrong. It takes too much effort to build and maintain stuff. Why??? I see three primary causes:

. Lack of knowledge, in two areas:
  .. (intrinsic) the problem itself - we do not understand it well enough and need to experiment and research; this is an intrinsic part of the job
  .. (extrinsic) our tools - i.e. we do not understand enough the programming language and the technology we use; I believe/hope there must be much better way of preventing this waste
    * this is exacerbated by the lack of observability, i.e. our inability to see clearly what is happening in the system and our code; something Bret Victor talked a lot about
. Language not fit to talk about the solution and problem - a https://blog.jakubholy.net/2022/language-of-simplicity/[topic I explore in a recent post]
. Complexity, both intrinsic (real world is a dirty beast) and extrinsic (related closely to #2) - I have mused https://blog.jakubholy.net/2021/simplicity/[about complexity in SW development] before

If you have any thoughts on this topic, please let me know!

== What is happening

A lot! Primarily I have been pretty busy building a simple ERP system for a friend, built on Fulcro RAD, Asami, and running on Fly.io. A considerable fraction of the time was spent on writing https://github.com/holyjak/fulcro-rad-asami[fulcro-rad-asami] v2 with support for Pathom 3 and transactional resetting of singular attributes, as well as on learning RAD and Pathom better and improving their code (e.g. a picker with support to create/edit entities) and docs. Why, you migt wonder? I feel that to support my current and future mentee clients better I need to maintain my hands-on experience. I like to help friends. And I wanted something that could have been turned into a teaching tool, showing people how to create a real app from 0 (though I am not sure I will figure out how to do this). It is also fun to be responsible for everything, from UI through security to operations and resillience.

In other news, in April I am going to the US for https://2023.clojure-conj.org/[Conj], THE Clojure conference. I am excited about both the conference and meeting some online friends in the real life for the first time.

== New blog posts

A mixture of SW dev, Clojure, and Fulcro stuff came out of my print press recently:
https://blog.jakubholy.net/2023/pathom-viz-for-fulcro-pathom3/[Get insight into Pathom 3 in Fulcro with Pathom Viz]
https://blog.jakubholy.net/2022/language-of-simplicity/[First craft a language then build your software] - one of the https://blog.jakubholy.net/best/[most important things] I've ever written, about the topic that is bothering me for years - why do we write so much code and spend so much time doing that. Though already Paul http://www.paulgraham.com/avg.html[Graham has indicated the answer] years ago and http://worrydream.com/[Bret Victor] has things to say here.
https://blog.jakubholy.net/2022/2022-in-review/[My year 2022 in review]
https://blog.jakubholy.net/2022/fulcro-detached-root-component/[Fulcro Lesson: Detached Root Component (Form)]
https://blog.jakubholy.net/2022/trinity-of-clojure/[Clojure is in fact a trinity - of language, interactive development, and structural editing] - a slightly controversial piece aimed at newcomers to Clojure and the approach to learning it, triggered by chats with my colleagues

== Gems from the world wide web

=== January 2023

++++
<p><span class="link">üëì <a href="https://mbezjak.github.io/posts/using-the-error-model/">Using the Error Model</a> [clojure, best practice, opinion]</span><br /><span style="white-space: pre-line;">A series on error handling providing good food for thought. Explores different kinds of errors, ways to represent them, what information you might want to include with an error, and finally how to work with them in the code (this installement). Something to ponder when you design error handling for your project!</span></p><p><span class="link">üëì <a href="https://grep.app/">grep.app | code search</a> [service]</span><br /><span style="white-space: pre-line;">Search across GitHub repos, filtering for a particular language etc. Useful to find examples of the usage of a library etc. </span></p><p><span style="white-space: pre-line;"><strong>Task scheduling libs for Clojure</strong><br /></span><br /><span style="white-space: pre-line;">Libraries for scheduling of tasks and batch jobs that are Clojure friendly.</span><br /><span style="white-space: pre-line;">Light-weight solutions:</span><ul><li><a href="https://github.com/jarohen/chime">Chime</a> - "create the simplest possible scheduler" - "[it] is really just a promise to execute a function at a (possibly infinite) sequence of times" I suppose "done" but with occasional updates (including mine!)</li><li><a href="https://github.com/aphyr/tea-time">Tea-time</a> (last updated 2019)</li><li><a href="https://github.com/overtone/at-at">at-at</a> (last updated 2014) - built on ScheduledThreadPoolExecutors. Not smart enough to see that a task is already scheduled.</li></ul><span style="white-space: pre-line;">Heavy-weight:</span><ul><li><a href="https://github.com/factorhouse/cronut">cronut</a> - a data-first Clojure wrapper for the popular, feature-rich Java <a href="http://www.quartz-scheduler.org/">Quartz Job Scheduler</a>. The README describes how it differs from older wrappers such as <a href="https://github.com/michaelklishin/quartzite">Quartzite</a> and <a href="https://github.com/prepor/twarc">Twarc</a>.</li><li><a href="https://github.com/nilenso/goose">goose</a> - "A Reliable [avoid data loss in face of HW/net/... failure], Pluggable [Message Broker, metrics backend] & Scalable background job processing library for Clojure."</li></ul></p><p><span class="link">üëì <a href="https://github.com/lambdaisland/deep-diff2">lambdaisland/deep-diff2: Deep diff Clojure data structures and pretty print the result</a> [clojure, library, data]</span><br /><span style="white-space: pre-line;">Recursively compare Clojure or ClojureScript data structures, and produce a colorized diff of the result - intended for human consumption.</span></p><p><span class="link">üëì <a href="https://github.com/Datomic/dev.datafy">Datomic/dev.datafy: Dev-time datafy and nav</a> [clojure, library, productivity]</span><br /><span style="white-space: pre-line;">Bring datafy and nav to commonly used mechanism types. Currently covers some of Java (socket, thread stuff, ...), core.async (channels, buffers), and reify. For use with REBL, Portal, etc.</span></p><p><span class="link">üëì <a href="https://jakewharton.com/using-jlink-to-cross-compile-minimal-jres/">Using jlink to cross-compile minimal JREs - Jake Wharton</a> [java, devops]</span><br /><span style="white-space: pre-line;">jlink is a JDK tool to create bespoke, minimal JREs for your applications. For a simple hello world example it reduces the JRE size from 140 to 30MB.</span><br /><span style="white-space: pre-line;">Though it might not be always so simple to figure out what modules are necessary - as Maarten explains in <a href="https://medium.com/de-bijenkorf-techblog/creating-the-smallest-jvm-microservice-deployment-14a039a1dcae">Creating the smallest JVM microservice deployment</a>: "<em>Unfortunately modularisation is not that popular because it‚Äôs hard to implement. The maintainers of Spring don‚Äôt think its worth implementing modularisation because of the costs. So, to use the jlink command, we have to manually add all the modules to the runtime, one by one, until our application runs.</em>"</span><br /><span style="white-space: pre-line;">Here is an article with a <a href="https://careers.wolt.com/en/blog/tech/how-to-reduce-jvm-docker-image-size">two stage Dockerfile build leveraging jlink</a> to create a custom JRE (with all modules included by default, read it to find out how to limit that).</span><br /><span style="white-space: pre-line;">You could also <a href="https://aws.amazon.com/blogs/opensource/using-graalvm-build-minimal-docker-images-java-applications/">consider using GraalVM to build a fast-starting, possibly smaller image</a>. Gene Kim has <a href="https://clojurians.slack.com/archives/C68M60S4F/p1640131135207300">done that for a Fulcro webapp</a> (reducing startup time from 25-30s in an uberjar to 8 seconds) (<a href="https://github.com/realgenekim/rss-reader-fulcro-demo">code here</a>).</span></p>
++++

=== December 2022

++++
<p><span class="link">üëì <a href="https://techcrunch.com/2022/11/28/aws-makes-lambda-cold-start-latency-a-thing-of-the-past-with-snapstart/?guccounter=1&amp;guce_referrer=YW5kcm9pZC1hcHA6Ly9jb20uZ29vZ2xlLmFuZHJvaWQuZ29vZ2xlcXVpY2tzZWFyY2hib3gv&amp;guce_referrer_sig=AQAAAMdmpaFJfJEuX-S2S3piACt5srLjxRrVmZW27LJqpE_AUbllwhzBfBWjnoEg2M7bypgkmmQfsGY5DQKeK1RMVEAqpTy8YL-QblUlQ39nk9CheSG1dO9l0Zf0UdMOFEVB466UFZObeVeq8xb8hG9yOl-9erKGZIHTQCQeIHefRRVf">AWS makes Lambda cold start latency a thing of the past with SnapStart | TechCrunch</a> [serverless, performance, devops]</span><br /><span style="white-space: pre-line;">Currently JVM-based lambdas running on the Correto JVM can reduce startup time by ~ 90% thanks to a memory & disk snapshot taken after initialization and used during subsequent starts.</span></p><p><span class="link">üëì <a href="https://chreke.com/little-languages.html?ref=upstract.com">Little Languages Are The Future Of Programming</a> [productivity, opinion]</span><br /><span style="white-space: pre-line;">Perhaps the most important text I have read this year. The author argues eloquently that ‚Äúlittle languages‚Äù ‚Äî small languages designed to solve very specific problems (think SQL or RegExp) ‚Äî are the future of programming. Do we really need 30 million lines of code to implement an operating system, or is 20k enough? An example is Nile, a little language for computer graphics, that in 300 lines of code can do what Cairo needs 40 000 lines of general purpose programing language code. How does this apply to your software project? This way: "The idea is that as you start to find patterns in your application, you can encode them in a little language‚Äîthis language would then allow you to express these patterns in a more compact manner than would be possible by other means of abstraction. Not only could this buck the trend of ever-growing applications, it would actually allow the code base to <em>shrink</em> during the course of development!"</span></p><p><span class="link">üëì <a href="https://eugenkiss.github.io/7guis/">7GUIs</a> [comparison, gui]</span><br /><span style="white-space: pre-line;">¬†"Benchmark" to compare GUI toolkits in terms of their notation. To that end, 7GUIs defines¬†seven tasks¬†that represent typical challenges in GUI programming.¬†</span></p><p><span class="link">üëì <a href="https://github.com/factorhouse/slipway#why-jetty">factorhouse/slipway: A Clojure Companion to Jetty</a> [clojure, library]</span><br /><span style="white-space: pre-line;">A Ring<->Jetty adapter for multiple versions of Jetty, even 5he newer one still lacking official Ring adapter. </span></p><p><span class="link">üëì <a href="https://github.com/jpmonettas/flow-storm-debugger/blob/flow-docs/docs/flow_docs.md">flow-storm-debugger/flow_docs.md at flow-docs ¬∑ jpmonettas/flow-storm-debugger ¬∑ GitHub</a> [clojure, tool, documentation]</span><br /><span style="white-space: pre-line;">Generate docs about the shape of function arguments by instrumenting them by the Flow Debugger and exercising them (typically by running the test suite). Produces an EDN and can display it in the debugger.</span></p><p><span class="link">üëì <a href="https://www.highflux.io/blog/highflux-method">More productive software development using the HighFlux method | HighFlux</a> [productivity, practice]</span><br /><span style="white-space: pre-line;">Great practice for more efficient, collaborative software coding. Key points: use a <em>monorepo</em> to prevent dependency hell <a href="https://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/fulltext">& more</a>, use WIPs, not feature branches, use feedback early and often.</span><br /><span style="white-space: pre-line;">WIPs are small, focused, frequently updated, short-lived branches, merged eventually as a single, squashed commit.</span><br /><span style="white-space: pre-line;">It should be possible to ask for feedback at any time, not only when the work is finished. Getting feedback on an initial design is most valuable. And we want to be able to get a quick feedback on a piece of code at any time.</span></p><p><span class="link">üëì <a href="https://github.com/donut-party/datapotato">donut-party/datapotato: better database fixtures for Clojure tests! ü•î</a> [clojure, library, testing]</span><br /><span style="white-space: pre-line;">A library for the generation of relational test data. A fork of Specmonstah that supports more schema providers than just Spec, has fixture lifecycle management, first-class support for inserting fixtures into databases, and is user friendlier.</span></p>
++++


+++--+++

Thank you for reading!

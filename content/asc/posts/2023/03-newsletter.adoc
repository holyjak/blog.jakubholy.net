{:title "Holy Dev Newsletter March 2023"
 :hide-from-home? true
 :date "2023-04-01"
 :tags ["newsletter"]}

Welcome to the Holy Dev newsletter, which brings you gems I found on the web, updates from my blog, and a few scattered thoughts.
You can get the next one into your mailbox if you link:/me/subscribe[subscribe].
// I am always eager to read your comments and ideas so do not hesitate to press the reply button!

== What is happening

Time is flying! This has been an intense period at work, which occupied most of my time, together with a little help I provided to two clients and coding the Fulcro ERP. When you maintain reporting capability for end users and have to upgrade the underlying query engine, which has extremely flexible and badly documented semantics and doesn't care enough about backwards compatibility and stability, you are in for a treat. Hopefully, thanks to a few good ideas and lot of work, it is over with minimal impact on customers üòÆ‚Äçüí®. But it drives home how awesome the Clojure philosophy of stability and not breaking contracts is.

The ERP is hopefully drawing to a close (the final 20%?  üòÖ). Right now I am refactoring from a monolithic order to an order with potentially multiple order lines, which is an interesting experience. I had to model this, move a bunch of attributes over, redesign my reports and forms, rewrite most queries, and implement cascading delete. Fortunately doable but not trivial. Some fallout from that is that https://github.com/holyjak/fulcro-rad-asami[fulcro-rad-asami] has got docs improvements and the `::asami/no-batch?` option to work around a https://github.com/wilkerlucio/pathom3/issues/194[Pathom 3 problem]. (Troubleshooting it was quite an ordeal, and I am very thankful to Caleb MacDonald Black and Wilker for their help.)

I have published https://github.com/holyjak/minimalist-fulcro-template-fly[minimalist-fulcro-template-fly], which extends the existing minimalist-fulcro-template with support for building and deploying it to the https://fly.io[Fly.io] cloud, and with connectivity to PostgreSQL. I had picked this DB because I expected most developers to be familiar with relational databases, while something like Asami is more obscure, and less universally applicable.

Outside of Clojure, I have stretched my feable CSS skills to add dark mode to my blog, when I noticed how impractical it was to read it in the dark. And these last few days I have been playing with https://clerk.vision/[Clerk], to analyze REST communication around some issues at work.

In the wider world, Electric Clojure (see below) has been finally released in v1.0, and I am looking forward to trying it out. Perhaps I will try to rewrite the ERP with it (after it is done!), to see how it delivers on its promise of simplifying web development. Overall, I feel the pull of doing more work on the backend and less on the frontend, retreating from the world of SPAs, and looking for more simplicity. As you can see from some of the links posted below.

Lastly, I am going to attend Conj üéâ and thus spent some time designing a Fulcro t-shirt to wear at the conference :-).

== Gems from the world wide web
++++
<p><span class="link">üëì <a href="https://github.com/beoliver/wiretap/">beoliver/wiretap</a> [clojure, library]</span><br /><span style="white-space: pre-line;">A tiny library by a colleague that enables you to capture the inputs and outputs of functions, e.g. in an atom - for example to record traces.</span></p><p><span class="link">üëì <a href="https://www.ambient.run/post/introducing-ambient">Introducing Ambient 0.1</a> [rust, library, wasm]</span><br /><span style="white-space: pre-line;">Ambient is a runtime for building high-performance multiplayer games and 3D applications,  written in Rust, powered by WebGPU, and compatible with any language that compiles to/runs on WebAssembly. The goal is to make building multiplayer as straightforward as building singleplayer.</span><br /><span style="white-space: pre-line;">Ambient is built with data-oriented design in mind from top to bottom. All data is stored in, and interacted through, an entity component system backed by a centralized entity database on the server. This database is automatically replicated to every client, and each client has the ability to augment and extend entities with local state. The use of an ECS makes it easy to visualize the state of your application and provides excellent performance and scalability.</span><br /><span style="white-space: pre-line;">I am not into gaming but it sounds cool and worth studying.</span></p><p><span class="link">üëì <a href="https://ergonomictrends.com/best-regular-mouse-alternatives/">9 Best Alternatives to a Regular Mouse (from an Ergonomist)</a> [health, productivity]</span><br /><span style="white-space: pre-line;">I am looking for an alternative to a regular mouse. I have an inflammation in my right writst, possibly due to the mouse. I have tried a vertical mouse (#5 in the list) but find it impractical to have to lift my hand from the keyboard, and also not terribly precise or efficient, compared to a trackpad (#9). Perhaps #1, Roller Bar Mouse, sitting at the base of the keyboard, could be interesting. Or an <a href="https://ergonomicsnerd.com/ergonomic-keyboards-with-trackball/">ergonomic keyboard with a trackball</a> (though their #1 doesn't look ergonomic to me at all; #5, Adesso WKB-3150UB, or #6 Perixx PERIBOARD-506, seem much more ergonomic to me).</span></p><p><span class="link">üëì <a href="https://github.com/matthewdowney/rich-comment-tests">matthewdowney/rich-comment-tests: RCT turns rich comment forms into tests.</a> [clojure, library, testing]</span><br /><span style="white-space: pre-line;">Turn code in rich comments (in the form of `statement ;=> <expected result>`) into clojure.tests, with support for partial matching via <a href="https://github.com/HealthSamurai/matcho">matcho</a>.</span></p><p><span class="link">üëì <a href="https://github.com/eerohele/tab">eerohele/tab: A tool for tabulating Clojure collections.</a> [clojure, tool, productivity]</span><br /><span style="white-space: pre-line;">A data viewer similar to Portal, but much simpler, with no dependencies, and only displaying the last tap-ed value as (nested, expandable) table. Uses a browser for the rendering. Leverages datafy.</span></p><p><span class="link">üëì <a href="https://github.com/pfeodrippe/recife">pfeodrippe/recife: A Clojure model checker (using the TLA+/TLC engine)</a> [clojure, tool] - <q>A Clojure model checker (using the TLA+/TLC engine) - GitHub - pfeodrippe/recife: A Clojure model checker (using the TLA+/TLC engine)</q></span><br /><span style="white-space: pre-line;">A model checker on Top of TLC, the program for running TLA+  formal specifications. With Recife, you can write them in Clojure! <a href="https://recife.pfeodrippe.com/notebooks/recife/notebook/slow_start.html">Learn more</a>, read the <a href="https://recife.pfeodrippe.com/notebooks/recife/notebook/reasoning.html">reasoning</a>.</span></p><p><span class="link">üëì <a href="https://www.propelauth.com/post/i-love-building-a-startup-in-rust-i-wouldnt-pick-it-again">I love building a startup in Rust. I wouldn't pick it again. | PropelAuth Blog</a> [rust, experience] - <q>For almost two years now, the vast majority of our backend code was written in Rust (aside from a little bit of Python). I love Rust, it‚Äôs b</q></span><br /><span style="white-space: pre-line;">"However, at a new startup, one of the core problems is to figure out if you are building something useful. A quick MVP can be invaluable in determining if you are on the right path or lost in the woods. All that time spent making readable, performant code might be wasted."</span><br /><span style="white-space: pre-line;">"Once you have that clarity, and you‚Äôve shifted to ‚ÄúIt‚Äôs time to scale‚Äù mode or ‚ÄúPerf actually is really important here‚Äù mode or even ‚ÄúWe have a solid direction/roadmap and we don‚Äôt want too much tech debt‚Äù mode, Rust is a fantastic choice." </span></p><p><span class="link">üëì <a href="https://opensource.com/article/19/4/gpg-subkeys-ssh">How to enable SSH access using a GPG key for authentication</a> [security] - <q>Learn how to eliminate SSH keys and use a GNU Privacy Guard (GPG) subkey instead.</q></span><br /><span style="white-space: pre-line;">I haven't tried this but it sounds interesting. Use GPG keys for SSH (run gpg-agent instead of ssh-agent, config it to enable-ssh-support, even preconfigure what keys to ssh add automatically, tell the system to use it by pointing SSH_AUTH_SOCK to it).</span></p><p><span class="link">üëì <a href="https://github.com/strojure/parsesso">strojure/parsesso: Parser combinators for Clojure(Script).</a> [clojure, library] - <q>Parser combinators for Clojure(Script)</q></span><br /><span style="white-space: pre-line;">Build a parser to parse a text into a data structure. The grammar is defined with function composition rather than the parser generator approach of using a DSL such as EBNF (as in Instaparse). Ex.: (def +space (p/+skip char/white?)).</span><br /><span style="white-space: pre-line;">See <a href="https://softwareengineering.stackexchange.com/questions/338665/when-to-use-a-parser-combinator-when-to-use-a-parser-generator">When to use a Parser Combinator? When to use a Parser Generator?</a> => in general, parser combinators such as parsesso are for creating top-down (i.e. LL) parsers, with the ability to reuse common code (this lib). Parser Generators typically generate a finite state automaton for a bottom-up (LR) parser. Though nowadays there are also combinators for LR grammars and generators for LL ones (e.g. ANTLR). "Which one you should use, depends on how hard your grammar is, and how fast the parser needs to be." Especially if the grammar has lot of non-trivial ambiguities then it might be easier with the more flexible combinators approach.</span><br /><span style="white-space: pre-line;">Have a look at <a href="https://softwareengineering.stackexchange.com/questions/338665/when-to-use-a-parser-combinator-when-to-use-a-parser-generator">Chet Corcos's Introduction to Parsers</a> article to understand more of the terms and background and learn more about parser combinators.</span></p><p><span class="link">üëì <a href="https://github.com/zalky/runway">zalky/runway: Coding on the fly, from take-off to landing, with a tool.deps reloadable build library</a> [clojure, productivity, tool]</span><br /><span style="white-space: pre-line;">Robust support for the "reloaded" REPL dev workflow for deps-based projects. Integration for Stuart's Component (and possibly more in the future), so that the system is restarted if any component changes. Optional support for loading env variables. Can load dependent namespaces eagerly (default) or lazily. It makes it possible to declare a separate deps alias for each thing to start (the app, nrepl, file watcher, ...) and start any subset by combining the aliases on the command line. </span><br /><span style="white-space: pre-line;">I feel my current setup is working fine enough but perhaps I should give it a try...</span></p><p><span class="link">üëì <a href="https://news.ycombinator.com/item?id=34771771">Electric Clojure ‚Äì A signals DSL for full-stack web UI | Hacker News</a> [clojure, library, architecture, important, webdev, productivity]</span><br /><span style="white-space: pre-line;">A discussion of the newly released Electric Clojure by Hyperfiddle. What is Electric? "Electric Clojure, a reactive Clojure/Script dialect for web UI with compiler-managed client/server data sync." What does that mean? You write a single piece of code, e.g. a UI component function, and hint which parts need to run on the server vs. the client. "The Electric compiler performs deep graph analysis of your unified frontend/backend program to automatically determine the optimal network cut, and then compile it into separate client and server target programs that cooperate and anticipate each other's needs." Thus you program as if there was no hard client-server divide (no 2 separate files with REST calls in between) and Electric handles splitting it up and managing the communication between them on your behalf. It is groundbreaking and fascinating, with potential to significantly simplify web apps. Go r<a href="https://github.com/hyperfiddle/electric#electric-clojure--a-signals-dsl-for-fullstack-web-ui-with-compiler-managed-network-sync">ead more about it</a>.</span><br /><span style="white-space: pre-line;"><strong>Highlights from the discussion</strong> (many comments by the founder):</span><br /><span style="white-space: pre-line;">[..] we're seeing 10x LOC reduction (18k to 2k) in rebuilding Electric's sister project, Hyperfiddle (a spreadsheet like tool for robust UI development), as well as massive gains in performance.</span><br /><span style="white-space: pre-line;">NOTE: Til now focus was on correct program semantics, now started work on DX etc.</span><br /><span style="white-space: pre-line;">Our DOM module is only 300 LOC - it's bare metal DOM point writes + Electric (reactive language) + macros for JSX-y syntax. When the programming language itself is reactive, DOM rendering falls out for free.</span><br /><span style="white-space: pre-line;">Mechanically, Electric is comparable to <a href="https://www.solidjs.com/">Solid.js</a> except the reactive engine (missionary) is general purpose, not coupled to DOM rendering, which is a special case of incremental view maintenance.</span><br /><span style="white-space: pre-line;">[..] over-abstracting is a primary risk and has been top of mind for us since project conception in ~2012. [..] Electric is an attempt to find exactly the right level of abstraction. The goal is to remove and flatten layers, not add them, thus decreasing abstraction weight in the end if we succeed. Maybe we fail, but first let me share some details about how we think about this:</span><ol><li>I've personally failed to build this project several times, Electric Clojure is something like the 7th attempt.</li><li>strong composition model as a starting point, based on category theory generalization of "function" -> "async function" -> "reactive function" -> "stream function" -> "distributed function". [..] (This rigor is in response to the past failures.)</li><li>Functional effect system (monad stuff) at the bottom, which provides strong semantics guarantees about glitch-free reactive propagation, process supervision (like Erlang) (transparent propagation of cancellation and failure), strong resource cleanup guarantees (DOM nodes can never be left hanging, event handlers can never fail to be detached and disposed). Already this results in tighter operational semantics than we have ever achieved with manual resource management (and, again, we tried, see past failures).</li><li>Electric affords the programmer trapdoors to the underlying FRP/concurrency primitives. Electric is essentially a Clojure-to-FRP compiler, so if you code raw concurrency and effect management, that actually typechecks with what Electric generates, allowing seamless transition in and out of the abstraction.</li><li>3k LOC + 3k test LOC is the size of Electric today (includes a rewrite of the Clojure analyzer). Spring Framework is, let me go check, 59k just for spring-core/src/main/java, and there are like 20 other modules I excluded. Indeed it is not a fair comparison but certainly we have complexity budget to spare.</li></ol><span style="white-space: pre-line;">About <a href="https://github.com/leonoel/missionary">Missionary</a>: "Missionary is a reactive dataflow programming toolkit providing referentially transparent operators for lazy continuous signals, eager discrete streams, and IO actions. Missionary aims to improve over state-of-the-art reactive systems, it can be used as a general-purpose asynchronous programming toolkit but also as a basis for event streaming and incremental computations." Electric uses it for functional effects and as its reactive engine.</span></p><p><span class="link">üëì <a href="https://fly.io/blog/how-we-got-to-liveview/">How We Got to LiveView</a> [webdev, architecture, productivity]</span><br /><span style="white-space: pre-line;">How LiveView in Phoenix, the unique Elixir web framework with first class realtime support, came to be. To me the most interesting part is that Phoenix, similarly to Electric Clojure and HTMX, moves state and logic to the backend (BE) and handles efficiently communicating changes to the (mostly?) static frontend (FE). A lot of webapp complexity IMO stems from synchronizing state on the FE and BE, so this is refreshing. Highlights:</span><br /><span style="white-space: pre-line;">FE and BE are connected by bidirectional Channels, which exploit Elixir/Erlang messages to talk with external clients. The FE opens a single WebSocket, which multiplexes between channels and processes. Because Elixir is preemptively scheduled, processes load-balance on both IO and CPU. You can block on one channel, transcode video on another, and the other channels stay snappy.</span><br /><span style="white-space: pre-line;">(An interesting feature is <a href="https://hexdocs.pm/phoenix/Phoenix.Presence.html">Phoenix Presence</a>, a distributed group manager with metadata backed by <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">CRDTs</a>. Presence gets used in IOT apps to track devices, cars, and other things. If you don't have something like Presence, you probably don't think to build the kinds of features it enables.)</span><br /><span style="white-space: pre-line;">With React, any state change triggers a re-render, followed by an efficient patch of the browser DOM. LiveView is the same, except the server re-renders the template and holds the state. [LiveView] compute[s] a minimal diff to send to the client of <em>only the dynamic data that has changed</em>. [..] we send a payload better optimized than the best hand-written JSON API.</span></p><p><span class="link">üëì <a href="https://zackoverflow.dev/writing/unsafe-rust-vs-zig/">When Zig is safer and faster than Rust</a> [rust, experience]</span><br /><span style="white-space: pre-line;">Experience report showing that Zig is "safer, faster, and easier to write" than corresponding <em>unsafe Rust. </em>The reason is that unsafe Rust is hard. A lot harder than C, this is because unsafe Rust has a lot of nuanced rules regarding its borrowing/ownership rules to make compiler optimizations, and you must not break those. Also, Zig had ‚Äúmore tools for working in a memory-unsafe environment, such as reporting memory leaks in tests‚Äù, making the overall process much better. Note that safe Rust is a completely different story.</span></p><p><span class="link">üëì <a href="https://gist.github.com/pesterhazy/9f7c0a7a9edd002759779c1732e0ac43">Minimalist migration framework for PostgreSQL ¬∑ GitHub</a> [devops, database, tool]</span><br /><span style="white-space: pre-line;">A simple `idempotent(migration_name text,code text)` stored function that only `execute` the migration `code` if the migration hasn't been run yet.</span></p><p><span class="link">üëì <a href="https://socket.dev/blog/introducing-safe-npm">Introducing "safe npm", a Socket npm Wrapper - Socket</a> [security, tool, javascript]</span><br /><span style="white-space: pre-line;">Socket‚Äôs ‚Äúsafe npm‚Äù CLI tool transparently wraps the npm command and protects developers from malware, typosquats, install scripts, protestware, telemetry, and more‚Äî11 issues in all.</span></p><p><span class="link">üëì <a href="https://xenova.github.io/transformers.js/#examples">Transformers.js - AI in the browser</a> [library, javascript, ai]</span><br /><span style="white-space: pre-line;">Translation, summarization, image recognition, image-to-text, and a whole lot more. </span></p><p><span class="link">üëì <a href="https://ably.com/blog/can-webtransport-replace-websockets">What is WebTransport and can it replace WebSockets? | Ably Blog: Data in Motion</a> [webdev, performance] - <q>WebTransport is a new specification offering an alternative to WebSockets, but can it replace them? We review WebSockets use cases to find o</q></span><br /><span style="white-space: pre-line;">WebTransport is in my understanding essentially improved WebSockets, with support for newer protocols for better performance, and having multiplexing and choice between reliable streams or faster communication with the risk of reordering or loss of packets. </span><br /><span style="white-space: pre-line;">It works with HTTP/2 or 3, possibly on top of the TCP replacement QUICK. With that there is less overhead and it avoids the head-of-line blocking delays that WebSockets suffers from.</span><br /><span style="white-space: pre-line;">HTTP/3 over QUIC, it‚Äôs faster to establish connections, and congestion control feedback is available to help avoid problems</span></p><p><span class="link">üëì <a href="https://github.com/google/rune">google/rune: Rune is a programming language developed to test ideas for improving security and efficiency.</a> [programming language, research, security, performance]</span><br /><span style="white-space: pre-line;">Really interesting, innovative language (in progress) with a unique focus: "Rune is a programming language developed to test ideas for improving security and efficiency." For example if you declare a type as secret, then computation on it will be done in constant time, preventing timing-based attacks. The other fascinating thing is that it is based on <a href="https://datadraw.sourceforge.net/">DataDraw</a>, which is an ultra-fast in-memory, optionally persistent, database for high performance programs written in C. The database and DB access code is compiled and linked into your program, reportedly  "making data manipulation even faster than if they were stored in native C data structures". It understands relationships, has cascading deletes, etc.</span></p><p><span class="link">üëì <a href="https://report.yerbo.co/">Yerbo. The State of Burnout in Tech in 2021.</a> [productivity, health]</span><br /><span style="white-space: pre-line;">A fun and visually attractive insight into a big problem: burnout in tech. According to the report, about 40% tech workers are in high and 30% in medium risk of burnout. Being overworked and unable to recharge, they are exhausted an start feeling they achieve less than they should (self-inefficacy). As a defense, they become cynical, i.e. stop caring about the work and performance, and detach emotionally, becoming colder and harsher to their colleagues. Until they collapse or leave...</span></p><p><span class="link">üëì <a href="https://techtalkbook.com/export-data-from-the-chrome-browser-console/">Export data from the Chrome browser console - Grow Together By Sharing Knowledge</a> [javascript, webdev, productivity]</span><br /><span style="white-space: pre-line;">A nice snippet to add fn console.save to save a data into a file as json from the browser Console. (When it might be too large for the clipboard, which you can do with navigator.clipboard.writeText.)</span></p>
++++

+++--+++

Thank you for reading!

// This newsletter is produced by Jakub Hol√Ω (https://holyjak.cz/), a blogger and programming buddy / mentor for hire.
// If youd don't want to receive it anymore, simple respond with "unsubscribe" in the subject

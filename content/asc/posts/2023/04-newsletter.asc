{:title "Holy Dev Newsletter April 2023"
 :hide-from-home? true
 :date "2023-04-30"
 :tags ["newsletter"]}

Welcome to the Holy Dev newsletter, which brings you gems I found on the web, updates from my blog, and a few scattered thoughts.
You can get the next one into your mailbox if you link:/me/subscribe[subscribe].
// I am always eager to read your comments and ideas so do not hesitate to press the reply button!

== What is happening

April has been an exciting month, as I have visited the ultimite world Clojure conference, namely https://2023.clojure-conj.org/[Conj] in the US. There have been some excellent talks, some good ones, and some disappointing ones. The best part was of course meeting people, especially those I only knew online, until now. You can see https://www.youtube.com/playlist?list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd[all the talks at YouTube]. I especially enjoyed https://www.youtube.com/watch?v=fTtnx1AAJ-c&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=1[Rich's talk on design], and https://www.youtube.com/watch?v=Gqlnu3ky5WI&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=3[Gaining Constant time Lookup over Unorganized Data], which demonstrates the desing process in practice, and describes how Nubank arrived to a disk-based hash map as an efficient solution to a problem recurring in different contexts. https://www.youtube.com/watch?v=eISbXkvLVJM&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=4[State of XTDB], https://www.youtube.com/watch?v=xEvkT9YeBQU&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=18[Clojure for Data Science in the Real World], https://www.youtube.com/watch?v=dTP2Ou1naXw&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=12[Operating Datomic at Scale], and https://www.youtube.com/watch?v=dqBeGpuedf0&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=23[Joyful Cross platform Development with ClojureDart] were certainly worth listening to, if you have any interest in the topics. https://www.youtube.com/watch?v=Z6xglREtPTY&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=8[High Performance Clojure] was an exciting deep dive into lessons Chris learned optimizing his data processing and parsing libraries. I have only seen the later half of https://www.youtube.com/watch?v=Ysl6nrPRRUQ&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=10[How to build a Clojure dialect], which isn't relevant to anything I do, but was really well presented and fun, so I want to see it whole. The talk https://www.youtube.com/watch?v=kxwvsoIx9p8&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=11[Clojure in the Fintech Ecosystem] wasn't very technical but it was anyway inspirational to me, especially in regards to Clojure for Data Science and learning how only the arrival of NumPy turned Python into the essential tool of data science it is today - and thus, how Clojure could do the same trick. https://www.youtube.com/watch?v=MNiqDZz-lp4&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=22[Emmy: Moldable Physics and Lispy Microworlds] demonstrated a https://github.com/mentat-collective/emmy[library for symbolic computations] in Clojure, which is far removed from what I do, but is fascinating anyway, and it proved how crucial it is to link:/2022/language-of-simplicity/[build the proper language] to solve a class of problems. I cannot imagine building the demos Sam presented without the library, with just a general purpose programming language. I haven't learned much from https://www.youtube.com/watch?v=WXtbndYRqBs&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=17[Real @toms with Clojure!] but it was fascinating to see a mathematician and a physicist giving a talk at a programming conference, and to see how the Clojure Data Science stack can be used for everything you need for a scientific paper, from data collection, to processing, to presentation (with fallback on Python libraries and Wolfram, accessible through Clojure bridges, where native capabilities lack for now). Next, we need to figure out how to reach out to scientists and help them adopt this, and how to make it as easy as possible for them, since they are busy with science, and not interested in learning programming, dealing with integration issues, or learning development best practices.

There is a couple of talks I haven't seen but want to check out - https://www.youtube.com/watch?v=KBN9qBSUv30&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=5[Fluree: an Immutable, Verifiable, Shareable Database], https://www.youtube.com/watch?v=NVBq3CUXsuE&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=13[Architecting systems through Engineering Principles], https://www.youtube.com/watch?v=cTV_UVIkwoY&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=16[Clojure lsp ‚Äì One tool to lint them all] (it was wonderful finally meeting Eric in person!), https://www.youtube.com/watch?v=BxK44tRhKMQ&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=19[BI and Reporting for Datomic], and https://www.youtube.com/watch?v=NwnfrK6woQc&list=PLZdCLR02grLpIQQkyGLgIyt0eHE56aJqd&index=24[Modern Frontend on ClojureScript and React in 2023] (just for a comparison with Fulcro).

üìñ tips: On the plane I have also done some reading. Namely I have started to re-read the excellent "business novel" https://www.amazon.com/Phoenix-Project-DevOps-Helping-Business-ebook/dp/B078Y98RG8[Phoenix Project]. The book is a real page turner, and teaches extremely valuable lessons - some that I have forgotten since my first reading many years ago. üíØ recommended to (re)read! I have also finally read the follow up, https://www.amazon.com/Unicorn-Project-Developers-Disruption-Thriving-ebook/dp/B07QT9QR41[the Unicorn Project], which explores the topic of what developers need to thrive and be maximally productive (the "Five Ideals"), and what companies need to do to stay relevant and not decline (the "Three Horizons"). The beginning was somewhat disappointing, a little forced and far less gripping than the Phoneix Project, but eventually the story really takes off and in the end it was absolutely worth reading. Even if the tech organization starts in a hellish place far removed from my working conditions, it goes through a rapid transformation and there are valuable lessons along to way for everyone. The maxim I keep repeating to myself is that the improvement of daily work is more important then the work itself (I guess unless you only improve and never do the work üòÄ). Finally, I have started on https://www.amazon.com/Escaping-Build-Trap-Effective-Management/dp/149197379X[Escaping the Build Trap: How Effective Product Management Creates Real Value], recommended to me when I worried about prioritizing and managing all the incoming work. For me as a developer manager, it would suffice with an abridged version if someone made one targetted at me :-). But it is good to get an insight into the product management part of the organization. I have studied Lean Startup before, so a bunch of the ideas wasn't really new, but I guess it never harms to remind us that management should set the direction, but let (value stream focused) teams figure out how to get there, through relentless focus on actual customer problems, and experimentation about that and possible solutions. A noteworthy point was that a corporate strategy shouldn't need to change often, and that it isn't a plan but a framework for making decisions. I also liked the hierarchy of vision - strategic intent - project intent (which merges with the previous one, if your company only has one product) - and "options," i.e. yet unverified ideas for achieving the intent. And the "product kata" - identify a goal, asses where you are with respect to it, discover the biggest problem between you and the goal, form a hypothesis how to get rid of it, experiment, evaluate. Rinse and repeat.

üõ†Ô∏è I have also done some more coding on https://github.com/holyjak/fulcro-rad-asami[fulcro-rad-asami], essentially to add support for cascading delete, which will simplify implementing the last feature in the tiny ERP I am building. I only need to fix the tests...

== Gems from the world wide web
++++
<p><span class="link">üëì <a href="https://developers.redhat.com/articles/2023/03/22/how-enable-opentelemetry-traces-react-applications#10_step_opentelemetry_demonstration">How to enable OpenTelemetry traces in React applications | Red Hat Developer</a> [devops, monitoring, reactjs]</span></p>

<p><a href='https://twitter.com/pam_rubin1/status/1635252696671461376'><img alt="A great summary of the book Making Work Visible, Exposing Time Theft to Optimize Work &amp; Flow by Dominica DeGrandis - the Five..." srcset="https://64.media.tumblr.com/61fe53c1675c389a39428c88f3cc98b4/5a459ca434b9a7ee-da/s1280x1920/fac20697f7f32f6599df5e6295172ed90e78cb32.jpg 1096,https://64.media.tumblr.com/61fe53c1675c389a39428c88f3cc98b4/5a459ca434b9a7ee-da/s640x960/7e2289e1403c5cc0b7fc1bd2602abc129d5928c1.jpg 640,https://64.media.tumblr.com/61fe53c1675c389a39428c88f3cc98b4/5a459ca434b9a7ee-da/s540x810/9388a90867c6b7b62958527679ec8909bd0c5022.jpg 540,https://64.media.tumblr.com/61fe53c1675c389a39428c88f3cc98b4/5a459ca434b9a7ee-da/s500x750/f2d5552d2059aeb87dddbbf1baa1a72e2011c014.jpg 500,https://64.media.tumblr.com/61fe53c1675c389a39428c88f3cc98b4/5a459ca434b9a7ee-da/s400x600/5eab77ff4640351b57ca4902384d47977ff076db.jpg 400,https://64.media.tumblr.com/61fe53c1675c389a39428c88f3cc98b4/5a459ca434b9a7ee-da/s250x400/23601b1669484dcfdf78e2acfb219f0c652edf2d.jpg 250,https://64.media.tumblr.com/61fe53c1675c389a39428c88f3cc98b4/5a459ca434b9a7ee-da/s100x200/0a70920580f423ad17f46fe529d97ad54e35a348.jpg 100,https://64.media.tumblr.com/61fe53c1675c389a39428c88f3cc98b4/5a459ca434b9a7ee-da/s75x75_c1/887b9ddcf9115b124805488d8fb9c7d016ccb9cf.jpg 75" /></a><br /><span style="white-space: pre-line;">A great summary of the book Making Work Visible, Exposing Time Theft to Optimize Work & Flow by Dominica DeGrandis - the Five Thieves of Time (1. Too much work in progress 2. Unknown dependencies 3. Unplanned work 4. Conflicting priorities 5. Neglected work), the key action - visualize the work - and their 8 takeaways of: 1. Don't spend more time managing than doing 2. Stop starting and start finishing (x WIP) 3. Communications was a problem 4. Reduce context switching 5. Set clear boundaries (and get better work-life balance) 6. Measure what matters (outcomes, not usage) 7. Build on collaboration 8. Create a spirit of continuous improvement</span></p><p><span class="link">üëì <a href="https://www.fermyon.com/blog/introducing-spin-v1">Spin 1.0 ‚Äî The Developer Tool for Serverless WebAssembly | Fermyon ‚Ä¢ Experience the next wave of cloud computing.</a> [wasm, productivity, tool]</span><br /><span style="white-space: pre-line;">Spin is an open source developer tool and framework that helps the user through creating, building, distributing, and running serverless applications with Wasm. The 1.0 release focused among others on connecting to databases, distributing applications using popular registry services, a built-in key/value store for persisting state, running your applications on Kubernetes, or integrating with HashiCorp Vault for managing runtime configuration.</span><br /><span style="white-space: pre-line;">You can deploy f.ex. to the WASM Fermyon Cloud (by the authors) or Kubernetes. </span></p><p><span class="link">üëì <a href="https://getcode.substack.com/p/efficient-extensible-expressive-typed">Efficient, Extensible, Expressive: Typed Tagless Final Interpreters in Rust</a> [rust]</span><br /><span style="white-space: pre-line;">This blew my mind (partially thanks to the idea, partially due to the high-level (for me) Rust). In short, we can look at designing APIs as designing Domain-Specific Languages and writing interpreters for this. A simple way to write a DSL is an enum with an entry for each operation or literal, to represent our Abstract Syntax Tree. An interpreter is then a fn using eg. pattern matching on the enum. This is called the "initial" style. However, this layer of abstraction adds overhead and prevents us from leveraging some capabilities of the host language, such as type checking of our DSL expressions, and pushes their evaluation to runtime.</span><br /><span style="white-space: pre-line;">The core is then introducing the "final" style, where we leverage host language constructs directly - numbers, functions, expressions are those of the host language. They are type-checked and evaluated at compile time. The DSL is defined using traits, with generic associated types (GAT). It is as expressive as the initial style, but more efficient and type checked. Which is critical for higher order languages, ie. DSLs that take a function as a value (think of map, filter, etc). Different interpreters are then different impl of the trait(s).</span><br /><span style="white-space: pre-line;">The final style also solves the expression problem of statically typed programming languages - ie. that it's hard to come up with an abstraction that is easily extensible with both behaviors (think adding multiplication to a calculator DSL) and representations (e.g. mathematically evaluating the expression vs printing it to a string). You only need to add the new operation to the trait and implement just that for each interpreter - and the compiler will tell you where.</span></p><p><span class="link">üëì <a href="https://www.scattered-thoughts.net/writing/assorted-thoughts-on-zig-and-rust/">Assorted thoughts on zig (and rust)</a> [zig, rust, thoughts]</span><br /><span style="white-space: pre-line;">A Rust expat in the land of Zig share their thoughts. In short, Rust is safer (eg. w.r.t. Use After Free and avoiding data races), but Zig is pretty safe too and far simpler to learn. From the beginning:</span><br /><span style="white-space: pre-line;">Zig is dramatically simpler than rust. It took a few days before I felt proficient vs a month or more for rust.</span><br /><span style="white-space: pre-line;">Most of this difference is not related to lifetimes. Rust has patterns, traits, dyn, modules, declarative macros, procedural macros, derive, associated types, annotations, cfg, cargo features, turbofish, autoderefencing, deref coercion etc. I encountered most of these in the first week. Just understanding how they all work is a significant time investment, let alone learning when to use each and how they affect the available design space.</span><br /><span style="white-space: pre-line;">I still haven't internalized the full rule-set of rust enough to be able predict whether a design in my head will successfully compile. I don't remember the order in which methods are resolved during autoderefencing, or how module visibility works, or how the type system determines if one impl might overlap another or be an orphan. There are frequent moments where I know what I want the machine to do but struggle to encode it into traits and lifetimes.</span><br /><span style="white-space: pre-line;">Zig manages to provide many of the same features with a single mechanism - compile-time execution of regular zig code. This comes will all kinds of pros and cons, but one large and important pro is that I already know how to write regular code so it's easy for me to just write down the thing that I want to happen.</span><br /><span style="white-space: pre-line;">One of the key differences between zig and rust is that when writing a generic function, rust will prove that the function is type-safe for every possible value of the generic parameters. Zig will prove that the function is type-safe only for each parameter that you actually call the function with.</span><br /><span style="white-space: pre-line;">On the one hand, this allows zig to make use of arbitrary compile-time logic where rust has to restrict itself to structured systems (traits etc) about which it can form general proofs. This in turn allows zig a great deal of expressive power and also massively simplifies the language.</span><br /><span style="white-space: pre-line;">On the other hand, we can't type-check zig libraries which contain generics. We can only type-check specific uses of those libraries</span></p><p><span class="link">üëì <a href="https://matklad.github.io/2023/03/26/zig-and-rust.html">Zig And Rust</a> [zig, rust, comparison]</span><br /><span style="white-space: pre-line;">Yet another comparison of Zig and Rust, with lot of interesting insights. A couple of highlights:</span><br /><span style="white-space: pre-line;">There is a fascinating side trip into the design of the  TigerBeetle DB, i.e. a fault-tolerant distributed system, such as: allocate all memory up-front, code is architected with brutal simplicity, aggressively minimize all dependencies, *all* inputs are passed in explicitly (including time), etc. TigerBeetle is essentially coded as a finite state machine. </span><br /><span style="white-space: pre-line;">Rust provides you with a language to precisely express the contracts between components, such that components can be integrated in a machine-checkable way. Zig doesn‚Äôt do that. It isn‚Äôt even memory safe (yay segmentation faults!). Zig is a much smaller language than Rust. Although you‚Äôll have to be able to keep the entirety of the program in your head, to control heaven and earth to not mess up resource management, doing that could be easier.</span><br /><span style="white-space: pre-line;">Zig has just a single feature, dynamically-typed comptime, which subsumes most of the special-cased Rust machinery. It is definitely a tradeoff, instantiation-time errors are much worse for complex cases. But a lot more of the cases are simple, because there‚Äôs no need for programming in the language of types.</span><br /><span style="white-space: pre-line;">Zig‚Äôs expressiveness is aimed at producing just the right assembly, not at allowing maximally concise and abstract source code.</span></p><p><span class="link">üëì <a href="https://github.com/typst/typst">typst/typst: A new markup-based typesetting system that is powerful and easy to learn</a></span><br /><span style="white-space: pre-line;">A modern replacement for LaTeX. Written in Rust. </span></p><p><span class="link">üëì <a href="https://flink.apache.org/">Apache Flink¬Æ ‚Äî Stateful Computations over Data Streams</a> [streaming, tool, data processing]</span><br /><span style="white-space: pre-line;">An interesting tool I did not know before. From the pages: "Apache Flink is a framework and distributed processing engine for stateful computations over <em>unbounded and bounded</em> data streams. Flink has been designed to run in <em>all common cluster environments</em>, perform computations at <em>in-memory speed</em> and at <em>any scale</em>." Can do also batch processing. You can use it for example for <a href="https://flink.apache.org/use-cases/#analytics">data analytics</a>, <a href="https://flink.apache.org/use-cases/#pipelines">data pipelining, and ETL applications</a>, leveraging SQL (with group by a time period) or its Table API. Flink can run e.g. on Kubernetes.</span></p><p><span class="link">üëì <a href="https://medium.com/the-serverless-edge/become-an-awesome-software-architect-with-these-12-books-2de6402d1187">Become an awesome Software Architect with these 12 books</a> [book, software development]</span><br /><span style="white-space: pre-line;">To help you become an awesome software architect, we have each picked our top four books to make 12 in total:</span><ol><li>Continuous Delivery (+ the great followup Modern Software Engineering)</li><li>Domain-Driven Design</li><li>Wardley Mapping</li><li>Accelerate</li><li>Extreme Ownership</li><li>Team Topologies</li><li>Reaching Cloud Velocity</li><li>Designing Data-Intensive Applications</li><li>Creativity Inc</li><li>Working Backwards</li><li>Ask Your Developer</li><li>The Software Architect Elevator</li></ol></p><p><span class="link">üëì <a href="https://orbstack.dev/">OrbStack ¬∑ Fast, light, simple Docker & Linux on macOS</a> [tool, docker, startup]</span><br /><span style="white-space: pre-line;">Docker Desktop alternative with reportedly better performance, less overhead, and more power (e.g. running Linux VMs alongside dockers). <a href="https://docs.orbstack.dev/faq#free">Free during beta</a>. "OrbStack is a drop-in replacement for Docker Desktop that's faster, lighter, simpler, and easier to use. See <a href="https://docs.orbstack.dev/compare/docker-desktop">OrbStack vs. Docker Desktop</a> for a detailed comparison."</span><br /><span style="white-space: pre-line;">Why is it fast? "OrbStack uses a lightweight Linux virtual machine with tightly-integrated, purpose-built services and networking written in a mix of Swift, Go, Rust, and C. See <a href="https://docs.orbstack.dev/architecture">Archiecture</a> for more details."</span></p><p><span class="link">üëì <a href="https://www.iconhunt.site/">Iconhunt - Search for open source icons, 150.000+ icons.</a> [tool, visuals, open source] - <q>A perfect search engine with 150.000+ free, open sources icons. Use them in Notion, Figma or download them with a single click.</q></span><br /><span style="white-space: pre-line;">Powered by the open-source <a href="https://frontendfoc.us/link/138200/86c8c88ea8">Iconify</a>, you can search by keyword, then grab the SVG as code or file download.</span></p><p><span class="link">üëì <a href="https://github.com/seancorfield/honeysql/blob/develop/build.clj">honeysql/build.clj at develop ¬∑ seancorfield/honeysql</a> [clojure, devops]</span><br /><span style="white-space: pre-line;">Example of a non-trivial Clojure tools-build build script by Sean Corfield. </span></p><p><span class="link">üëì <a href="https://github.com/serverlessworkflow/specification/issues/216">Replace JSONPath with 'jq' ¬∑ Issue #216 ¬∑ serverlessworkflow/specification</a> [tool, discussion, data processing]</span><br /><span style="white-space: pre-line;">An insightful discussion abour replacing JSONPath with jq or other alternatives. The main reason being that JSONPath lacks power and flexibility: "JSONPath was designed to query JSON documents for matches, especially arrays. It wasn't designed to handle complex logic, and the limitations in the spec show. JSONPath's inability to reference parent objects or property names of matching items forces users to contort their data in all sorts of strange ways." Also, support in different languages is reportedly bad. Also mentions <a href="https://jmespath.org/specification.html">https://jmespath.org</a> as a formally specified alternative to jq.</span></p><p><span class="link">üëì <a href="https://mitmproxy.org/">mitmproxy - an interactive HTTPS proxy</a> [tool, webdev]</span><br /><span style="white-space: pre-line;">Open-source man-in-the-middle proxy for troubleshooting, recording, repplaying, and modifying HTTP(s) and http/2 and WebSocket traffic. Set it as your <a href="https://docs.mitmproxy.org/stable/overview-getting-started/#configure-your-browser-or-device">browser's proxy</a> and start playing! It is primarily a CLI but comes with a web UI (in beta) and Python API. Install it as a certificate authority in you OS for simpler proxying of HTTPS. See its <a href="https://docs.mitmproxy.org/stable/overview-features/">lists of features</a>: anticache, blocklist (none/hardcoded response), map requests to files, change req URL, modify body, modify headers, ... . You can use/create addons - including integrating with Kubernetes services. You can <a href="https://docs.mitmproxy.org/stable/concepts-modes/#wireguard-transparent-proxy">set it up as a "transparent proxy"</a> (powered by WireGuard) when you can't change the client's config.</span><br /><span style="white-space: pre-line;">The blog post <a href="https://hiphish.github.io/blog/2022/06/12/fake-web-backend-with-mitmproxy/">Fake web backend with mitmproxy</a> demonstrates one possible use, with a simple addon to send hardcoded response based on the request. This post about <a href="https://sufiyanyasa.com/blog/mitmproxy-better-filters/">the most useful filters for developers</a> (by domain, http status, excluding assets, etc.) is also useful A bunch of other interesting ideas on Mitmproxy's <a href="https://mitmproxy.org/publications/">Publications</a> page. </span></p><p><span class="link">üëì <a href="https://blog.datomic.com/2023/04/datomic-is-free.html">Datomic - Datomic is Free</a> [database]</span><br /><span style="white-space: pre-line;">Datomic is now available free of licensing fees!!! </span></p>
++++

+++--+++

Thank you for reading!

// This newsletter is produced by Jakub Hol√Ω (https://holyjak.cz/), a blogger and programming buddy / mentor for hire.
// If youd don't want to receive it anymore, simple respond with "unsubscribe" in the subject

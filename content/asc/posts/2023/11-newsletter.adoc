{:title "Holy Dev Newsletter Nov 2023"
 :hide-from-home? true
 :date "2023-11-30"
 :tags ["newsletter"]}

// TODO: 1) Email: send to self + subscribers in BCC
// TODO: 2) Email: comment-out the four `//email:` below & comment-out L14 + `bb build` or `serve` (not fast!), copy & paste into email
// TODO: 3) All **links must be ABSOLUTE** (to work for email)
// TODO: 4) Re-comment the four `//` & publish to blog

Welcome to the Holy Dev newsletter, which brings you gems I found on the web, updates from my blog, and a few scattered thoughts.
//email: (Also https://blog.jakubholy.net/2023/11-newsletter/[available online].)
You can get the next one into your mailbox if you link:/me/subscribe[subscribe].
//email: I am always eager to read your comments and ideas so do not hesitate to press the reply button!

== What is happening

Exciting times! The gods of time have finally allowed me and https://www.youtube.com/watch?v=SE5Ge4QP4oY[Thomas Clark] to get in sync and https://github.com/scicloj/wolframite/discussions/17[start reviving Wolframite], a bridge between Clojure and the awesome https://www.wolfram.com/language/[Wolfram Language] and its built-in knowledge base. I am very excited about Wolfram because of the high level where it operates, its integration with scientific computing, and the integrated knowledge base. It truly makes everything "computable". With Wolframite, you can (soon) call to the free-for-dev Wolfram Engine or a full installation of Mathematica to do some work for you. If we are lucky then we will have Wolframite 1.0 by the end of the year. (Disclaimer: Wolframite is a refactoring of an older Clojuratica, and 99% of the work has been done by others. Me and Thomas just want to bring it to a conclusion and get it into your hands.)

Aside of Wolfram, I have also spent too much ðŸ˜… time with improving my blog, namely updating https://github.com/cryogen-project/cryogen-asciidoc/pull/17[cryogen-asciidoc to AsciidoctorJ v3], and consequently updating my https://github.com/holyjak/blog.jakubholy.net/commit/4aa97c7368f7c10b28272345c2e8a99b02d15b1f[builder to java > 8] (Netlify still only offers v8). I have also written a short note about https://blog.jakubholy.net/2023/4-heads-of-complexity/[The Four Heads of Complexity], based on a post by Kent Beck. (You should absolutely check out https://tidyfirst.substack.com?r=18k2mk[his newsletter Software Design]. Click on the "No thanks >" link at the bottom of the page to get a preview and some free posts.)

Finally, I have spent many hours these past two weeks on implementing pagination. You'd think it is a solved problem, but it turns out to be pretty complicated, when the entries come from 6 different tables. I hope to have time to write some property-based tests for this beast, and work on simplification in future iterations.

== Gems from the world wide web
++++
<p><span class="link">ðŸ‘“ <a href="https://www.photopea.com/">Photopea | Online Photo Editor</a> [tool]</span><br /><span style="white-space: pre-line;">A free online image editor. I haven't tried it, but it may be handy. There is also reportedly vector editor Vectorpea... </span></p><p><span class="link">ðŸ‘“ <a href="https://www.phoronix.com/news/Google-Linux-Binder-In-Rust">Google Rewriting Android's Binder In Rust With Promising Results - Phoronix</a> [rust, experience]</span><br /><span style="white-space: pre-line;">Google is rewriting Binder, the inter-process communication module in the Android kernel, from C to Rust. The key motivation is the complexity of the existing code. Moving ensuring ownership from developers to the compiler makes it simpler and more secure. Another benefit is that error handling is checked by the compiler, and simpler.</span></p><p><span class="link">ðŸ‘“ <a href="https://sequoia-pgp.org/">Sequoia-PGP</a> [rust, security, tool, library]</span><br /><span style="white-space: pre-line;">Sequoia-PGP is a new OpenPGP implementation, focused on security and correctness. And while it comes with the sq command-line tool, it was primarily created as a library. You can <a href="https://securedrop.org/news/migrating-securedrops-pgp-backend-from-gnupg-to-sequoia/">read about SecureDrop's switch</a> to it.</span></p><p><span class="link">ðŸ‘“ <a href="https://dev.to/javidjms/git-write-better-commits-with-gitmoji-3193">ðŸ”¨ [git]: Write better commits with Gitmoji</a></span><br /><span style="white-space: pre-line;">Emojis in commit messages FTW! </span></p><p><span class="link">ðŸ‘“ <a href="https://kerkour.com/should-i-rust-or-should-i-go">Should I Rust or should I go?</a> [rust, opinion, criticism] - <q>&#34;Is Rust a great fit for this project?&#34; I get this question quite frequently so I think it&#39;s time to write down my thoughts if i</q></span><br /><span style="white-space: pre-line;">A great and uncompromising analysis of the donwsides of Rust (when compared to Go), and of when it still makes sense. Go is almost as easy to use as Python,  and (reportedly) faster and more reliable than Java. </span><br /><span style="white-space: pre-line;">Some of the problems with Rust are how quickly it is changing (31 releases, while Go had 8 and Python 3), causing a lot of churn in the ecosystem. Moreover, it is becoming more and more comlex. Additionally, it can still be consider just a "beta" in the sense that async support is not fully implemented yet (such as async traits). (Though <a href="https://www.tumblr.com/holyjak/729199962288799744/the-state-of-async-rust-runtimes">async is really hard</a>, and may well be the next Billion Dollar Mistake.) Moreover, the standard library is very anemic, and you have to pick from incompatible libraries & approaches.</span><br /><span style="white-space: pre-line;">Rust still makes sense for WebAssembly, replacing C/C++/Assembly, and when you need insane performance.</span></p><p><span class="link">ðŸ‘“ <a href="https://github.com/oliyh/oxbow">oliyh/oxbow: A Server Sent Events (SSE) client for Clojurescript based on js/fetch</a> [ClojureScript, library, networking] - <q>A Server Sent Events (SSE) client for Clojurescript based on js/fetch - GitHub - oliyh/oxbow: A Server Sent Events (SSE) client for Clojures</q></span><br /><span style="white-space: pre-line;">Oxbow is a a cljs Server Sent Events client based on js/fetch, allowing you to use the full feature set of fetch and not be constrained by the old js/EventSource (which cannot e.g. send headers). js/fetch does not natively process streams, such as SSE. Oxbow handles this for you.</span></p><p><span class="link">ðŸ‘“ <a href="https://github.com/igrishaev/pg">igrishaev/pg: PostgreSQL driver in pure Clojure</a> [postgresql, clojure, library, database]</span><br /><span style="white-space: pre-line;">PostgreSQL driver in pure Clojure, with an excellent support for (multi-dimensional) arrays (automatically converted from/to Clojure vectors) and json. Easy integration with HoneySQL.</span><br /><span style="white-space: pre-line;">It seems to be still very much in progres, and promises a more ergonomic interface than JDBC and first-class access to features of Pg not so well / at all supported by JDBC. F.ex. it offers "various ways to <a href="https://github.com/igrishaev/pg/blob/master/doc/090-copy.md">COPY data into or from</a> the database. It's much more flexible than the official JDBC Postgres driver's standard <a href="https://jdbc.postgresql.org/documentation/publicapi/org/postgresql/copy/CopyManager.html">CopyManager</a> class." It also supports both the <a href="https://blog.hackeriet.no/Simple-and-Extended-postgresql-queries/">Simple and Extended Query / wire protocol</a>, with their separate pros and cons.</span></p><p><span class="link">ðŸ‘“ <a href="https://github.com/taoensso/tempel">taoensso/tempel: Data security framework for Clojure</a> [clojure, library, security]</span><br /><span style="white-space: pre-line;">Tempel is a lightweight encryption framework that wraps the JVM's native crypto facilities to provide a high-level Clojure API that is: idiomatic, simple, and easy-to-use even for non-experts. It incorporates best practices and reasonable defaults to help simplify many <a href="https://github.com/taoensso/tempel/wiki/2-Examples">common data security needs</a> such as log ins, encryption, signing, etc. Future-proof data formats with auto-updated algorithms and work factors over time</span></p><p><span class="link">ðŸ‘“ <a href="https://github.com/fractl-io/fractl">fractl-io/fractl: Generative AI-powered Programming Language</a> [research, programming languages]</span><br /><span style="white-space: pre-line;">Fractl is built on top of Clojure and exposes a dataflow-driven reactive programming model, with a functional core. (Existing Clojure/Java libraries are compatible with Fractl.) Its key aspects are Â higher level of abstraction and data-oriented syntaxÂ - which are intended to make it easier to create no/low code solution by using their SaaS build-code-by-connecting-boxes studio and being easier for AI code generation tools like Copilot. <a href="https://www.fractl.io/">Fractl.io</a>'s pitch is "SaaS Apps 100x Faster". The SaaS product is there to earn them living, but the Fractal language itself and key tooling for it are open source.</span><br /><span style="white-space: pre-line;">Fractal's high-level abstractions:</span><ol><li><strong>Graph-based Hierarchical Data Model</strong> - compose the high-level data model of an application as a hierarchical graph of business entities with relationships. Such <a href="https://docs.fractl.io/docs/concepts/data-model">entities and relationships</a> are first-class constructs in Fractl.</li><li><strong>Zero-trust Programming</strong> - tightly control operations on business entities through <a href="https://docs.fractl.io/docs/concepts/zero-trust-programming">declarative access-control</a> (RBAC) encoded directly in the model itself.</li><li><strong>Declarative Dataflow</strong> - express business logic as <a href="https://docs.fractl.io/docs/concepts/declarative-dataflow">purely-declarative patterns of data</a>.</li><li><strong>Resolvers</strong> - use a simple, but <a href="https://docs.fractl.io/docs/concepts/resolvers">powerful mechanism</a> to interface with external systems. A resolver is associated with an entity and consists of a map of functions implementing CRUD + query</li><li><strong>Interceptors</strong> - <a href="https://docs.fractl.io/docs/concepts/interceptors">extend the fractl runtime</a> with custom capabilities.</li><li><strong>Entity-graph-Database Mapping</strong> - take advantage of an <a href="https://docs.fractl.io/docs/concepts/entity-db-mapping">abstract persistence layer</a> for fully-automated storage of entity instances. Essentially an ORM ðŸ˜± but hopefully better.</li></ol><span style="white-space: pre-line;">Check out this <a href="https://github.com/fractl-io/fractl#a-taste-of-fractl">taste of Fractl code</a>.</span><br /><span style="white-space: pre-line;"><div class="indented" style="padding-left: 1em">Quote: "Our early users tell us that theÂ  combination of graph data model and role+ownership-based (similar to row-level, but much more powerful) access control help with making their app complete and very secure."</div></span><br /><span style="white-space: pre-line;">Websockets and GraphQL are coming...</span></p><p><span class="link">ðŸ‘“ <a href="https://github.com/zeitstein/brimm">zeitstein/brimm: Notion-inspired versatile knowledge management backed by a graph you own, full stack and open source.</a> [tool, documentation, knowledge management]</span><br /><span style="white-space: pre-line;">A full-stack <strong>open-source</strong> versatile graph knowledge management webapp, inspired by Notion and infinite outliners like Worflowy/Roam/Logseq. Coming in Q1 2024.Â </span><br /><span style="white-space: pre-line;">Built with XTDB, shadow-grove, SCI & more.</span><br /><span style="white-space: pre-line;">The primary motivation was to combine Notionâ€™s database and document editing experience with the structural flexibility of infinite outliners (apps like Workflowy or Logseq). The broader vision for Brimm is to provide you with a capable personal/team graph database with a default UI.</span><br /><span style="white-space: pre-line;">Brimm lets you model data as <a href="https://github.com/zeitstein/brimm#how">blocks of many shapes</a> (text, tasks, bookmarks, personal info, events, books, music albums, contact info, etc.), categorise and organise it, make connections, and search across it. You can "mirror" blocks elsewhere, create live queries rendered e.g. in a table, .. .</span><br /><span style="white-space: pre-line;">The core data model is "graph of nodes [blocks] with properties" [such as a date, tags picker, ...]. You can mould your data and workflows using Clojure through <a href="https://github.com/babashka/sci">SCI</a> - derive new facts, write a script to import external facts, ... .</span></p><p><span class="link">ðŸ‘“ <a href="https://grishaev.me/en/ddd-lie">Data-Driven Development is a Lie</a> [clojure, design, criticism]</span><br /><span style="white-space: pre-line;">A sharp article with a good point: encoding complex logic in ad-hoc data DSL with a home-made, ad-hoc interpreter is a recipe for defects, inflexibility, and expensive maintenance. Using simple, rather dull functions is far .... simpler. Though I do not think the author covers all of what "data-driven" (or should we rather say data-oritented?) means. Look at the benefits of data-driven Reitit vs. macro-base Compojure.</span></p><p><span class="link">ðŸ‘“ <a href="https://developer.chrome.com/blog/wasmgc/">WebAssembly Garbage Collection (WasmGC) now enabled by default in Chrome - Chrome for Developers</a> [wasm]</span><br /><span style="white-space: pre-line;">WebAssembly Garbage Collection is crucial for making higher-level languages practical with WASM, making it unnecessary to bundle their own, typically huge, GC. The standard is still under development, but obviously far along, as it is already enabled in both Chrome and Firefox. <a href="https://kotl.in/wasmgc">Kotlin/Wasm</a> has been integrating it for some 1/2 year and can already run a lot of stuff.</span></p><p><span class="link">ðŸ‘“ <a href="https://github.com/stickfigure/blog/wiki/How-to-%28and-how-not-to%29-design-REST-APIs">How to (and how not to) design REST APIs</a> [design, networking, experience]</span><br /><span style="white-space: pre-line;">Some great advice here. A summary follows, but read the original post for its rich experience and reasoning behind the recommendations. I especially like and/or have been surprised by, but agree with, nr. 4, 6, 7, 8. 11 is wonderful.</span><ol><li>DO use plural nouns for collections - /products/<id></li><li>DON'T add unnecessary path segments - e.g. Etsy's /shops/{shop_id}/listings/{listing_id} should have been /listings/{listing_id} b/c a listing_id is globally unique, and what if a listing switches shop?</li><li>DON'T add .json or other extensions to the url, use established headers!</li><li>DON'T return arrays as top level responses, always wrap them in an object - that way you can evolve it and add other keys in the future (e.g. for pagination)</li><li>DON'T return map structures for collections, e.g. {key1: {key: "key1",..}, :key2: ...} - use an array of maps (see also #4)</li><li>DO use strings for all identifiers, even if internally they are numbers - strings provide more flexibility, as things change over time (you can num -> str, not always the opposite)</li><li>DO prefix your identifiers with a type marker - much more ergonomic, better for troubleshooting</li><li>DON'T use 404 to indicate "not found" - non-intuitive (b/c that's what 404 is for!) but logical - b/c 404 could be returned by any intermediate proxy and thus could mean many different things, such as misconfigured client/proxy/load balancer hitting the wrong url. (The author suggests to use 410 gone.)</li><li>BE consistent (Shopify has 6 subtly different schemas for an Address in their REST.)</li><li>DO use a structured error format, if multiple layers of services are involved. Ex.: {message, type, types: ["Unauthorized", "Security",even a higher-level category for this error], cause: {<nested error>}}</li><li>DO provide idempotence mechanisms - ideally via an "idempotency key" or "client reference ID" - a client-provided value that you store temporarily or permanently and ensure its uniqness (by ignoring subsequent POSTs with the same one). Or let the client pick the id. On resubmit, you can either return 409 Conflict (which requires a smarter client that can handle it) or 201 with the original response (=> client can be dumb, but server becomes significantly more complex)</li><li>DO use ISO8601 strings for timestamps, not numbers like milliseconds-since-epoch, because human readability matters. And all timestamps should be in UTC.
Actually, use ISO8601 for all date/time-related values (durations, intervals, ...).
But DON'T trust your language/platform defaults - verify them (e.g. to ensure it use UTC and not the local timezone).</li></ol></p><p><span class="link">ðŸ‘“ <a href="https://www.youtube.com/playlist?list=PLH6-VpZ3SvUUKFSEPEWiHQi4JqebBj9Tq">EuroRust 2023</a> [rust, learning]</span><br /><span style="white-space: pre-line;">Talks from EuroRust 2023. Especially <a href="https://www.youtube.com/watch?v=4_FGYGv-vUU&amp;list=PLH6-VpZ3SvUUKFSEPEWiHQi4JqebBj9Tq&amp;index=7">Rust at Sentry: 7 Years Later</a> and <a href="https://www.youtube.com/watch?v=WmTBZhV4Lyc&amp;list=PLH6-VpZ3SvUUKFSEPEWiHQi4JqebBj9Tq&amp;index=13">Lessons Learned from Teaching Rust</a> seem interesting, though I haven't seen either.</span></p><p><span class="link">ðŸ‘“ <a href="https://www.juxt.pro/blog/juxtcast-rama-clojure-api/">JUXT Blog: JUXTCast: Rama and its Clojure API â€” with special guest Nathan Marz</a> [research, rama, design]</span><br /><span style="white-space: pre-line;">A great way to learn about Rama, the programming platform for building backends with very diverse compute and storage needs end-to-end, and including deployment and monitoring. It is massively scalable and fault tolerant. Programmable datastore on steroids - mold it to fit your domain, rather than vice versa.</span><br /><span style="white-space: pre-line;">It all started by examining scalable backends from first principles: what backend does is answer questions => can be modelled as a function of all the data it has ever seen. To make it practical, introduce the concept of an index and thus make it a function of data + indices.</span><br /><span style="white-space: pre-line;">Normally, you use a set of tools to build a backend: perhaps a relational DB + ElasticSearch + perhaps other DBs for the storage data, and perhaps Storm + an API server + custom workers to compute the indices, and possibly something yet different for the querying part.</span><br /><span style="white-space: pre-line;">Our field is all about abstraction, automation, and reuse, so you'd expect that each backend consists primarily of what is unique to it - yet the opposite is true. Rama wants to change that.</span><br /><span style="white-space: pre-line;">Every app needs multiple types of indices, and it needs them fit its particular needs.</span><br /><span style="white-space: pre-line;">Rama's depot an PState storage is based on Fb's <a href="https://rocksdb.org/">RocksDB</a>.</span><br /><span style="white-space: pre-line;">Rama introduces data-flow programming paradigm. A key building block is a "fragment," which is a generalization of a function - it can emit 0, 1, or many times, possibly to multiple streams. (A fn emits exactly once, to a single stream, and is done after that.)</span></p>
++++

+++--+++

Thank you for reading, and Merry Christmas!

//email: This newsletter is produced by Jakub HolÃ½, a blogger and programming buddy / mentor for hire.
//email: If you don't want to receive it anymore, simple respond with "unsubscribe" in the subject

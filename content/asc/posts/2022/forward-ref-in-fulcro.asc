{:title "Using React.forwardRef in Fulcro"
 :date "2022-07-03"
 :tags ["Fulcro", "ClojureScript"]
 :category "SW Development"}

How (and why) do you use https://reactjs.org/docs/forwarding-refs.html[React.forwardRef] in Fulcro? Let's first explore `ref`. When you need access to the https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement[_raw_ HTMLElement] in React - f.ex. to call `.focus` on it - you need to create a https://reactjs.org/docs/hooks-reference.html#useref[_Ref object_]footnote:[By "Ref" I will refer to the atom-like, mutable content holder, contrary to "ref" meaning the magical `ref` property and. Confusing, I know.] (similar to Clojure's atoms) and pass it to a _React DOM_ element such as `dom/div` via the magical property `:ref`. React will then do something like "(reset! <the Ref> <the raw element>)" so that you can access the raw element in your code: `(some-> <the Ref> .-current .focus)`. The `:ref` property is magical in the regard that it is "consumed" by React itself and not passed to the component. But what if you make a custom component and want it to be able to take a Ref object to attach it to its child DOM element? The simplest solution is to pass it under any other name than the reserved `ref`, which is exactly what https://github.com/fulcrologic/fulcro/blob/91fe23917d48eb7bfbe480eef2ed02ede3a4389b/src/workspaces/com/fulcrologic/fulcro/cards/ref_cards.cljs#L41[this Fulcro examples does], using the custom `:forwarded-ref`. However some 3rd party higher-order components insist on passing the Ref down using the reserved `ref` property name. To make it possibly, React invented `forwardRef`:

```js
const FancyButton = React.forwardRef((props, ref) =>
  (<button ref={ref} className="FancyButton">{props.children}</button>));

const ref = React.createRef();
<FancyButton ref={ref}>Click me!</FancyButton>;
```

What is happening here? `React.forwardRef` takes a _function_ accepting _props_ and _ref_ - i.e. the properties and the actual Ref object passed to the component FancyButton - and is expected to return a React _element_, which presumably uses of the props and the ref. `React.forwardRef` itself returns a _component_ and thus needs to be turned into an _element_ to be rendered. The component produced by `forwardRef` is magical and will not consume `ref` as normal components do, instead passing it on to the callback. (It cannot simply pass it on to the body of the component because that would violate the existing contract or mess something up, I assume.) Now, how do we use this in Fulcro?

## A simple example with a ref and use-ref

First a simple example where we do not need forwardRef. We want to create a button that, when clicked, focuses an input element:

.Using ref in Fulcro
====
```clojure
(defsc Root [_ _]
  {:use-hooks? true}                  ; <1>
  (let [^:js ref (hooks/use-ref nil)] ; <2>
    (div
      (dom/input {:ref ref, :value "" :type "text"})        ; <3>
      (dom/button {:onClick #(some-> ref .-current .focus)} ; <4>
        "Focus!"))))
```
<1> We need `:use-hooks? true` to be able to use hooks
<2> Create the Ref object with the initial value of `nil`
<3> Pass the Ref to the `input` element using the magical `:ref` prop so that React will capture it and set it to the raw DOM element
<4> Use the Ref's current value - the raw element - to focus the input field
====

## The smart way: passing a Ref to a child using a custom name

If we have full control over all the components involved then the simplest approach is to avoid `ref` and pass the Ref object under any other name. Here we have the same example as above but we have factored the button into a custom component, for reasons:

.Passing a Ref using a custom name
====
```clojure
(defsc ChildWithRef [_ {:keys [forwarded-ref label] :as props}]
  {}
  (dom/button {:onClick #(some-> forwarded-ref .-current .focus)}
    label))

(def ui-child-with-ref (comp/factory ChildWithRef))

(defsc Root [_ _]
  {:use-hooks? true}
  (let [^:js ref (hooks/use-ref nil)]
    (div (dom/h1 "Hello!")
      (dom/input {:ref ref, :value "" :type "text"})
      (ui-child-with-ref {:forwarded-ref ref :label "Focus, v2!"}))))
```
====

## Using forwardRef to access `ref` passed by a parent

Sometimes we do not control all the components and one of them insist on passing a Ref using the reserved `ref` and we thus must use forwardRef:

.Using forwardRef
====
```clojure
(defsc ChildWithRef [_ {:keys [forwarded-ref label] :as props}] ; <1>
  {}
  (dom/button {:onClick #(some-> forwarded-ref .-current .focus)}
    label))

(def ui-child-with-ref (comp/factory ChildWithRef))

(def child-with-ref
  (react/forwardRef                         ; <2>
    (fn [js-props ref]
      (ui-child-with-ref                    ; <3>
        (-> js-props
            (js->clj :keywordize-keys true) ; <4>
            (assoc :forwarded-ref ref))))))

(defsc Root [_ _]
  {:use-hooks? true}
  (let [^:js ref (hooks/use-ref nil)]
    (div
      (dom/input {:ref ref, :value "" :type "text"})
      ((interop/react-factory child-with-ref) ; <5>
        {:ref ref :label "Focus, v3!"}))))    ; <6>
```
<1> Our Fulcro-based Child component receives the Ref object using a custom name, `forwarded-ref` (could be anything but I found `:anything` little unclear ;))
<2> We call `react/forwardRef` passing it a callback that takes `props` and the passed-in `ref`.
<3> The callback returns a React _element_
<4> We need to manually translate the props that is a _JavaScript_ Object into a Clojure map and we add to it the passed-in `ref` under a custom name
<5> `forwardRef` returns a _component_ so we need to pass it through the factory to turn it into an element (for brevity I do it inline here)
<6> We simulate an external component that insists on passing the Ref as `:ref` and also pass in additional props that we need
====

## Summary

Sometimes you want to pass a Ref object - for example to get its values set to a raw HTMLElement by React - through a custom component. The simplest way is to use an arbitrarily named property for that. Some existing components like to use the reserved `ref` property for that purpose, which then requires the use of `React.forwardRef` to be able to get hold of the value passed in, which would otherwise be consumed by React itself.

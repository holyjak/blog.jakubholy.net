{:title "Bad Code: Are We Thinking Too Little?",
 :date "2013-12-30",
 :layout :post,
 :tags ["opinion" "design" "legacy"],
 :tags-orig ["design" "legacy" "opinion"],
 :categories ["General"],
 :extra-css #{}
}

++++
Do we not think enough when coding? Do we jump to the first solution without really considering the problem, without trying to analyze and decompose it and understand the components and orthogonal forces invovled? Is that the cause of bad code (together with time press) and the reason why we typically see a "patchvolution" rather than evolution (of design)?<br><br>For example I want a certain item on my list shown grayed out because it has been marked for removal or is currently being edited and I therefore add a flag called <em>isDisabled</em>. But if I really thought about it, I would likely call it based on the purpose rather than display, e.g. <em>isBeing Edited</em>. And I have often observed that I/we tend to jump to the first acceptable solution without trying to consider other, (radically) different and perhaps better alternatives. That is easily explained with our inborn intelectual laziness and we certainly can agree that we should not overthink things and that we need to ship but still, shouldn't we try to think a little more?<br><br>The Clojure community has been very inspiring for me in this regard. There is a strong focus on spending more time on the problem than the solution to really understand it, and on separating the different concerns involved and adressing them separately, as well as on achieving simplicity. One of the manifestation is the strong preference of small, focused, composable libraries over frameworks. F.ex. it took couple of years for Clojure to get support for named arguments - but the result - <a href="https://blog.jayfields.com/2010/07/clojure-destructuring.html">destructuring</a> - is something much more powerful, that now pervades the whole languages (of course, this is a language, not an app). When you listen to Rich Hickey talking f.ex. about <a href="https://www.infoq.com/presentations/clojure-core-async">core.async</a> (vs. actors, Reactive Extensions etc.) you see that the man thought deeply about the problem, alternatives, and their pros and cons.<br><br>May be we should spend little more time with our problems before jumping to solutions, no matter how much we like to solve things. Perhaps we would end up with a much better code than we typically have, and thus considerably lower maintenance costs.<br><br>Ref: <a href="https://www.infoq.com/presentations/Simple-Made-Easy">Simple <em>Made Easy</em></a>, <a href="https://www.drdobbs.com/architecture-and-design/the-clojure-philosophy/240150710">The Clojure Philosophy</a> from Joy of Clojure.<br><br><p style="text-align:center;"><em>You might enjoy also other <a href="/tag/opinion/">posts on effective development</a>.</em></p>
++++

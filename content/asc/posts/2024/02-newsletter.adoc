{:title "Holy Dev Newsletter February 2024"
 :hide-from-home? true
 :date "2024-02-29"
 :tags ["newsletter"]}

// TODO: 1) Email: send to *self* + subscribers in BCC
// TODO: 2) Email: comment-out the four `//email:` below & fix the MM in the first one & comment-out the subscribe L14, then `bb serve` (not fast! <> utf8), copy & paste into email
// TODO: 3) All **links must be ABSOLUTE** (to work for email)
// TODO: 4) Re-comment the four `//` & publish to blog

Welcome to the Holy Dev newsletter, which brings you gems I found on the web, updates from my blog, and a few scattered thoughts.
//email: (Also https://blog.jakubholy.net/2024/MM-newsletter/[available online].)
You can get the next one into your mailbox if you link:/me/subscribe[subscribe].
//email: I am always eager to read your comments and ideas so do not hesitate to press the reply button!

== What is happening

I keep a dialog with Thomas about Wolframite. We haven't done much lately, but have https://github.com/scicloj/wolframite/discussions/17?sort=new#discussioncomment-8623126[planned the way towards v1]. I have been primarily busy with Rama, finishing reading the docs and doing another round of learn-by-coding, as you can read in xref:hands-on-rama-day2.adoc[Hands on Rama, day 2: Rewrite CAS, finish basic C\(R)UD]. (You can catch https://blog.jakubholy.net/tags/rama/[the whole series here].) I went a little overboard and submitted a Rama talk to https://2024.javazone.no/[JavaZone], a big and popular conference here in Oslo. ðŸ¤ž

I have also been digging into efficient and relevant text search, as I have been working with a suggestion API here at Ardoq. I've spent too much time with ðŸ“• https://nlp.stanford.edu/IR-book/html/htmledition/irbook.html[Introduction to Information Retrieval] (free online, 2008), which is an excellent resource. I've learned about dictionaries, inverted indices (term â†’ document), k-grams for wildcard queries, smart techniques for intersections of lists etc. I got me thinking about how limited I am with Postgres, and how could I leverage Rama's ordered set for a better solution (until it gets 100% built-in support for rich text search). I've also learned finally what vector embeddings are, and wondered whether I could leverage those...

== Gems from the world wide web
++++
<p><span class="link">ðŸ‘“ <a href="https://github.com/BrunoBonacci/where">BrunoBonacci/where: Human readable predicate functions and `filter` best companion.</a> [clojure, library, data, productivity]</span><br /><span style="white-space: pre-line;">Neat little library for more conscise creating and combining of predicates, e.g. for filtering maps. The invocation api is trivial: (where extractor comparator target). F.ex. [:country = "Italy"]  extracts the value of :country and compares it with = against the target of "Italy". All comparators are nil-safe and the string comparators have a case-insensitive variant. See more <a href="https://github.com/BrunoBonacci/where/blob/master/doc/example.md">examples</a>.</span><br /><span style="white-space: pre-line;">Example: In Clojure: (->> xs (filter #(and (= (:country %) "Italy) (= (:country "USA")))). Where: (->> xs (filter (where [:or [:country = "Italy"] [:country = "USA"]])).</span></p><p><span class="link">ðŸ‘“ <a href="https://www.georgefairbanks.com/ieee-software-v36-n3-may-2019-principle-of-least-expressiveness">George Fairbanks - IEEE Software - The Pragmatic Designer: Principle of Least Expressiveness</a> [opinion, software eevelopment]</span><br /><span style="white-space: pre-line;">An inspiring article. P.L.E.: "When programming a component, the right computation model for the component is the least expressive model that results in a natural program [i.e. the solution is closer to the nature of the problem]." I.e. use the simplest construct suitable for the problem. Simplicity ordering: constant < variable < table < state machine < a Turing-complete programming language. E.g. use a lookup table if enough instead of an if-elses.</span><br /><span style="white-space: pre-line;">Why? It is clearer what the code can do (ie.e. paradoxically, using less expressive code expresses better the intent :)). It is more difficult to break its design integrity. "The idea is that by applying the PLE, we can write clearer code that better reveals how we think about the problem." "[Â± using] less expressive representation[...] stimulates a cascade of reasoning that shakes out an improved understanding." "we reveal our thoughts to readers in the least complicated way". While a Turing-complete language is rather vague, we want to use something more precise.</span></p><p><span class="link">ðŸ‘“ <a href="https://nuejs.org/blog/tailwind-vs-semantic-css/">Tailwind vs Semantic CSS</a> [css, opinion, webdev]</span><br /><span style="white-space: pre-line;">This study compares two websites with identical design, one built with Tailwind vs the same site with semantic CSS. Tailwind needs significantly more coding because you are completely lacking the power of CSS: the way it cascades and the richness of the selectors. You are forced to wrap divs inside divs inside divs and fill the elements with Tailwind-specific class syntax. (Some 7-10x more - though it is not shared how much the external CSS of semantic css wieghts.)</span><br /><span style="white-space: pre-line;">Seems to be <a href="https://nuejs.org/docs/why-nue/content-first.html#move-faster-by-writing-less-code">written by NueJS people</a>, comparing their solution to Tailwind with NextJS, so it may not be 100% objective.</span></p><p><span class="link">ðŸ‘“ <a href="https://tidyfirst.substack.com/p/tidy-first-in-one-page">Tidy First? in One Page</a> [productivty, software development, opinion]</span><br /><span style="white-space: pre-line;">Kent Beck summarizes his upcoming booklet <em>The Surprise Factory</em>, which explains to executives why care about software design. Summary:</span><br /><span style="white-space: pre-line;"><div class="indented" style="padding-left: 1em">This book will help you, an executive in a software-based business, create a Surprise Factory, a team frequently delivering pleasant surprises. Sound unlikely? I hope youâ€™ll stick with me. The missing ingredient is software design (aka "paying down technical debt" aka "refactoring"), but in the right proportions at the right times.

If you only have a minute to read, here are the classic software design blunders:

* Thou shalt not rewrite the whole system.
* Thou shalt not pause delivery of features for an extended period to fix the design.
* Thou shalt not delay the first feature to "get the design right".
* Thou shalt not thoughtlessly demand the next feature immediately upon completion of the last.

Why not, & what to do instead, are the topic of this briefing.
Mixing software design into development isnâ€™t one of those monochrome problems. Your team needs your judgement, perspective, & vision to balance todayâ€™s needs & tomorrowâ€™s opportunities.</div></span></p><p><span class="link">ðŸ‘“ <a href="https://ericnormand.substack.com/p/would-you-rather-structurally-avoid">Would you rather structurally avoid problems or detect them?</a> [software development, criticism]</span><br /><span style="white-space: pre-line;">Great food for thought. Do we choose unnecessarily complex solutions and then pile on tools to make them manageable, instead of adopting simpler architectures? For example, is Rust with its (costly) memory safety truly an improvement over C, or does it only make the mess caused by bad design choices manageable, i.e. could we instead make simpler design choices that make Rust unnecessary? I.e. "[..] memory management needs Rust because of lousy architecture." The Rust borrow checker is a complex solution, which allows for complex code. Couldn't we rather write simpler code?  Erlang's garbage collection is far simpler than JVM's because it made a simpler architecture choice of each process having its own, isolated heap.</span></p><p><span class="link">ðŸ‘“ <a href="https://nlp.stanford.edu/IR-book/html/htmledition/irbook.html">Introduction to Information Retrieval</a> [book]</span><br /><span style="white-space: pre-line;">A free book (2008) by Stanford on information retrieval and text search. Good source to for a refresh of text search algorithms, indices, and data structures. F.ex. leading/trailing <a href="https://nlp.stanford.edu/IR-book/html/htmledition/wildcard-queries-1.html#sec:wildcard">wildcard queries</a> (use regular/reverse B-tree to get to terms, then an inverted index for term -> documents). Other interesting topics include <a href="https://nlp.stanford.edu/IR-book/html/htmledition/scoring-term-weighting-and-the-vector-space-model-1.html">Scoring, term weighting and the vector space model</a> and <a href="https://nlp.stanford.edu/IR-book/html/htmledition/index-compression-1.html">Index compression</a>. </span></p>

<p>
<span class="link">ðŸ‘“ <a href="https://github.com/lilactown/flex">flex is a reactive signal library for Clojure(Script) </a> [webdev, ClojureScript, library]</span><br />
<span style="white-space: pre-line;">flex is a library for building computations using signals in Clojure(Script) - an approach made popular by SolidJS and others, recently. A "signal" is a reactive data holder, which updates when any of its dependencies change.</span></p><p><span class="link">ðŸ‘“ <a href="https://openjdk.org/jeps/453">JEP 453: Structured Concurrency (Preview)</a> [java, standard, concurrency]</span><br /><span style="white-space: pre-line;">A proposal (started 4/2023) for a new JVM API for structured concurrency, which "treats <em>groups of related tasks</em> running in different threads as a single unit of work, thereby streamlining error handling and cancellation, improving reliability, and enhancing observability." Goals: Help eliminate common risks arising from cancellation and shutdown, such as thread leaks and cancellation delays. Improve the observability of concurrent code. Read its "Motivation" section for a concrete example where this helps.</span></p><p><span class="link">ðŸ‘“ <a href="https://parenteser.mattilsynet.io/tailwindcss/">En uke med Tailwind CSS</a> [webdev, css, criticism]</span><br /><span style="white-space: pre-line;">A short and sweet article (in Norwegian) about cons and pros of Tailwind CSS, something I have wondered about recently. The advantage seems to be that T. gives you higher-level, composable utilities, such as md:flex to set element to display: flex on medium+ display sizes. And it provides tools to ensure you end up only with the CSS you actually need. The key disadvantage is that you end up with tons of classes on all styled elements, and a lot of repetition. The proposed solution to that is to use instead reusable <em>semantic classes</em> such as button-primary - something that the Tailwind plugin <a href="https://daisyui.com/">DaisyUI</a> offers.</span><br /><span style="white-space: pre-line;">Interestingly, Tailwind stands in a strong opposition to semantic CSS. The author derives that the there are different definition of "semantic" and you need to pick the right granularity - i.e. not the business domain (e.g. .shopping-cart), but the UI domain (.button-primary and other UI components). Good stuff!</span></p><p><span class="link">ðŸ‘“ <a href="https://open.substack.com/pub/ericnormand/p/people-over-process">People over process</a> [productivty, opinion, software development]</span><br /><span style="white-space: pre-line;">A long and thoughtful article about software development methodologies and productivity. The key thesis is that you can't achieve productivity by adopting a process, whether Scrum, XP, or anything else. The only thing that works is when leadership truly embraces continuous improvement, and enables you to arrive to a process that works for you, and iterate on it. In other words, it is about people.</span></p><p><span class="link">ðŸ‘“ <a href="https://mlochbaum.github.io/BQN/">BQN: finally, an APL for your flying saucer</a> [programming languages]</span><br /><span style="white-space: pre-line;">A modern successor to APL, the array programming language I learned about when dipping my toes in data science. Array-oriented programming is quite different from mainstream approaches, and thus worth studying. BQN has learned from two generations of predecessors, but also from languages outside of the array family. As the author writes, "I think BQN is a good choice for learning and enjoying array programming, scripting, prototyping, and number crunching at a single-CPU scale." Moreover, you can use some crazy characters in your code! Certainly something I'd like to do!</span><br /><span style="white-space: pre-line;">Side note: <a href="http://www.appliedscience.studio/articles/array-programming-for-clojurists.html">Array languages for Clojurians</a> (thanks, Teodor!) essentially argues that Clojure can be shaped to do everything an array-oriented language can, though perhaps at times less efficiently.</span></p><p><span class="link">ðŸ‘“ <a href="https://tonsky.me/blog/clj-reload/">New Library: clj-reload</a> [clojure, library, productivity]</span><br /><span style="white-space: pre-line;">A new alternative to tools.namespace (<a href="https://tonsky.me/blog/clj-reload/#comparison-toolsnamespace">comparison</a>), which tries to be smarter: </span><ul><li>you can have per-ns unload-hook (instead of a single, global one)</li><li>it returns the unloaded and loaded namespaces as data</li><li>you can protect selected def(|n|type|record|protocol) from reloading, instead of just whole namespaces (^:clj-reload/keep meta). defonce is protected automatically. It has also the keep-methods multimethod.</li><li>it only reloads ns that have been loaded, and only if they changed, while t.ns. reloads everything</li></ul></p><p><span class="link">ðŸ‘“ <a href="https://www.juxt.pro/blog/uri-templates/">JUXT Blog: URI Templates</a> [webdev, standard, library]</span><br /><span style="white-space: pre-line;">A useful reminder about the largely unknown power and potential usefulness of URI templates. "URI Template supports more sophisticated features, such as embedding lists and maps ...".</span><br /><span style="white-space: pre-line;">Also, the mentioned <a href="https://github.com/juxt/reap">Reap library</a> "for decoding and encoding strings used by web protocols," seems useful. It uses parser combinators and basic "parsing expression grammers" to make translating the grammar from a standard trivial, and exposes rfc&lt;num&gt;.clj with high-level fns, such as compile-uri-template and make-uri / match-uri.</span></p><p><span>ðŸŽ¥ <a href="https://www.youtube.com/watch?v=kn9nvHEgzJY">lambdaisland/launchpad, the ultimate dev env & repl launcher</a></span><br /><span style="white-space: pre-line;">Great walkthrough of <a href="https://github.com/lambdaisland/launchpad">lambdaisland/launchpad</a>, the ultimate dev env & repl launcher. Highlights: integrates deps.edn and .env with local overrides for both, picks up changes to either automatically (i.e. adding a new dependency to the classpath of a running repl). Support for Portal, shadow-cljs, starting any other process (shadow build, a Docker stack, ...) or running commands before/after. Enable deps aliases at runtime. Custom watchers - run a fn when a file changes. Monorepo support. May run user/go after start. This tool looks very useful and I will certainly give it a try!</span></p><p><span class="link">ðŸ‘“ <a href="https://phronmophobic.github.io/clip.clj/semantic-image-search-with-clojure/">Semantic Image Search with Clojure</a> [ai, learning, clojure]</span><br /><span style="white-space: pre-line;">Are you also constantly hearing about vector embeddings, vector databases (e.g. <a href="https://github.com/unum-cloud/usearch">usearch</a>), and how they can be used e.g. to find an image matching a textual prompt? Adrian provides a great explanation.</span><br /><span style="white-space: pre-line;">See <a href="https://github.com/phronmophobic/usearch.clj">usearch.clj</a> (vectordb wrapper), <a href="https://github.com/phronmophobic/clip.clj">clip.clj</a> (clj wrapper for a neural network model for computing embeddings -> <a href="https://github.com/mlfoundations/open_clip">OpenClip</a>).</span></p><p><span class="link">ðŸ‘“ <a href="https://conjurernix.github.io/convex-overview.html">High Level Overview of the Convex Decentralised Network from a Clojure Developer's perspective</a> [web3, blockchain, clojure]</span><br /><span style="white-space: pre-line;"><a href="https://convex.world/">Convex</a>, the "Decentralised Engine for Open Economic Systems," is a modern alternative to blockchains such as Ethereum for building decentralized apps (dApps), designed to handle the scale of Visa at much lower energy consumption that traditional blockchains. Moreover, it uses a Clojure-inspired Convex Lisp for its smart contracts a.k.a. actors. Instead of a traditional, linear blockchain, it combines a lattice-based structure with Conflict-Free Replicated Data Types (CRDTs) => more efficient data organization and access. <a href="https://github.com/convex-dev/convex.cljc">Clojure lib</a>. Interestingly, it is reportedly suitable for creating decentralized, real-time, multi-player games - something you'd never do on a blockchain. It could also be used to create an interactive dApp, such as a social network.</span><br /><span style="white-space: pre-line;">This article introduces Convex, its features and future, and compares its performance with Ethereum, though the authors note that the definition of a "transaction" varies widely, and Convex is geared towards more complex ones. From the conclusion: "Convex, with its lattice technology, integration with Clojure, and focus on functional programming, represents a significant step forward in the decentralized technology space. It offers developers not just a new technology but a new philosophy for building secure, efficient, and scalable decentralized applications."</span><br /><span style="white-space: pre-line;">I would absolutely look into Convex, were I ever to build a decentralized app. (Though I'd be wary of security and <a href="https://www.tumblr.com/holyjak/738167197067788288/the-third-web">fundamental brokenness</a> until proven otherwise, as I am with all blockchains. )</span></p><p><span>ðŸŽ¥ <a href="https://youtu.be/8Ab3ArE8W3s">Jack Rusher's thought-inspiring talk Stop Writing Dead Programs (transcript here). Key message: Don't preserve practices that...</a></span><br /><span style="white-space: pre-line;">Jack Rusher's thought-inspiring talk <em>Stop Writing Dead Programs</em> (<a href="https://jackrusher.com/strange-loop-2022/">transcript here</a>). Key message: Don't preserve practices that have no rational basis beyond being historical - which we do a lot. Such as 80 char width (from punch cards). Jack takes us on an excursion into the history of computing and across the landscape of programming languages (featuring Clojure, Erlang, Forth, Smalltalk, and many others).</span><br /><span style="white-space: pre-line;">Summary: "live" programs enable you to interact with, explore, debug, and change the code at run-time. "Dead" programs have the batch thinking / compile/run cycle. Also, we have many opportunities to discover more productive practices.</span><br /><span style="white-space: pre-line;">"Docker shouldn't exist. It exists only because everything else is so terribly complicated that they added another layer of complexity to make it work." ðŸ¤£</span><br /><span style="white-space: pre-line;">Jack talks about many things in programming languages that have nor really evolved much - seeing program is a static artifact, expecting it / optimizing for it to run from start to finish (vs. the long-lived servers we actually write). Few languages help with managing <em>state over time</em> from multiple sources. <em>Program representation</em> is still just primitive text, no leveraging our powerful visual cortex (pictures, tables, ...). The lack of <em>interactive programming</em> [..] the only kind of programming we should really be doing. A discussion of types (loves Haskell, hasn't really seen fewer bugs thanks to types).</span><br /><span style="white-space: pre-line;">Programming is actually a design discipline - you figure out what you're building as you build it. And all software is continuous change. (Which has consequences for types and any specs.) => debuggability is more important than correctness by construction. "I would say that actually most programming is debugging." Yet "dead coding languages" don't help much. In Common Lisp, Clojure I can attach to a running process, inspect anything, change anything [my words]. The <a href="https://gtoolkit.com/">Glamorous toolkit</a> (for Smalltalk?) is built to give you great visibility into your running program.</span><br /><span style="white-space: pre-line;">Other topics</span><ul><li>Error handling and Common Lisps amazing <a href="https://www.tumblr.com/holyjak/676159238831226880/condition-systems-in-an-exceptional-language">condition system</a></li></ul></p><p><span class="link">ðŸ‘“ <a href="https://shoelace.style/">Shoelace: A forward-thinking library of web components.</a> [webdev, library]</span><br /><span style="white-space: pre-line;">An open-source library of framework agnostic <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Components">Web Components</a>, with localization, dark theme, React support. <a href="https://shoelace.style/components/alert">Components list</a>.</span></p>
++++

+++--+++

Thank you for reading!

//email: This newsletter is produced by Jakub HolÃ½, a blogger and programming buddy / mentor for hire.
//email: If you don't want to receive it anymore, simple respond with "unsubscribe" in the subject

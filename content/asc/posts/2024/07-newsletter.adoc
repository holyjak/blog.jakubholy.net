{:title "Holy Dev Newsletter July 2024"
 :hide-from-home? true
 :date "2024-07-31"
 :tags ["newsletter"]
 :asciidoctor {:attributes {"relfileprefix" "https://blog.jakubholy.net/2024/"}}}

// TODO: 0) Fix TODOs to set the correct date, month above
// TODO: 1) Email: send to *self* + subscribers in BCC (SCHEDULED, after the blog post goes live)
// TODO: 2) Email: comment-out the four `//email:` below
//          & fix the MM in the first one
//          & comment-out the subscribe L18, then `bb serve` (not fast! <> utf8), copy & paste into email
// TODO: 3) All **links must be ABSOLUTE** (to work for email) - xref + relfileprefix work
// TODO: 4) Re-comment the four `//` & un-comment L18 & publish to blog

Welcome to the Holy Dev newsletter, which brings you gems I found on the web, updates from my blog, and a few scattered thoughts.
//email: (Also https://blog.jakubholy.net/2024/07-newsletter/[available online].)
//email: I am always eager to read your comments and ideas so do not hesitate to press the reply button!
You can get the next one into your mailbox if you link:/me/subscribe[subscribe].

== What is happening

We are wrapping up our Clojurist Together sponsorship of https://github.com/scicloj/wolframite[Wolframite], the Clojure ‚Üî Wolfram bridge for scientific computing. We have fixed everything required for v1, added some ergonomics improvements, and made very good progress on https://scicloj.github.io/wolframite/[our new docs site] (thank you, Thomas!).

Also, summer and holiday!

== Gems from the world wide web
++++
<p><span class="link">üëì <a href="https://slack.engineering/balancing-old-tricks-with-new-feats-ai-powered-conversion-from-enzyme-to-react-testing-library-at-slack/">Balancing Old Tricks with New Feats: AI-Powered Conversion From Enzyme to React Testing Library at Slack - Slack Engineering</a> [experience, ai]</span><br /><span style="white-space: pre-line;">A fascinating story of migrating a huge codebase from one testing framework to a rather different one. AST transformations proved too complex, and they stopped at ~ 45% eyes code. LLM was at first not very good: "Despite our best efforts, we encountered significant variation and inconsistency. Conversion success rates fluctuated between 40-60%. The outcomes ranged from remarkably effective conversions to disappointingly inadequate ones, depending largely on the complexity of the task. " Prompt engineering seemed to only perplex it. The solution: provide more context and guidance (the corresponding DOM tree, partially converted code from the AST approach) => the integration of both AST and AI technologies, helped us achieve the remarkable 80% conversion success rate. Especially the partially converted code and suggestions generated by the initial AST-based codemod "yielded remarkable results," successfully minimized hallucinations and nonsensical conversions. </span></p><p><span class="link">üëì <a href="https://charity.wtf/2024/01/05/questionable-advice-my-boss-says-we-dont-need-any-engineering-managers-is-he-right/">Questionable Advice: ‚ÄúMy boss says we don‚Äôt need any engineering managers. Is he right?‚Äù</a> [way-of-working, management]</span><br /><span style="white-space: pre-line;">An interesting question: why do we need engineering managers? (Thank you, Anton!) The author argues that hierarchy has not been invented to oppress people (though it is sometimes used that way) but that it is an emerging property of self-organizing systems, which is "is absolutely critical to the adaptability, resiliency, and scalability of complex systems." Especially, "<em>Hierarchy minimizes the costs of coordination and reduces the amount of information</em> that any given part of the system has to keep track of." Applying this to engineering organizations, "we can say that a manager‚Äôs job is to coordinate between teams and help their team perform better." They build relationships and wider context that makes them better at their job, while it allows engineers to focus on their job. Also, management labor consists of frequent context switching (meetings and stuff), which would kill any "maker." "If you‚Äôre trying to hold your <em>tech leads</em> responsible for building healthy engineering teams, tools, and processes, you are asking them to do two calendarily incompatible jobs with only one calendar. The likeliest scenario is that they will focus on the outcomes they feel comfortable owning (the technical ones), while you pile up organizational debt in the background."</span></p><p><span class="link">üëì <a href="https://www.firezone.dev/blog/sans-io">sans-IO: The secret to effective Rust for network services</a> [rust, opinion, architecture]</span><br /><span style="white-space: pre-line;">A fascinating article arguing for the "sans-IO" approach to writing code and libraries. It's about pushing I/O (even reading current time) to the outskirts of your system. The core of your code becomes I/O-less, written as side-effect free, pure state machines. It is wrapped by a side effecting shell of "event loops", that bridge between the pure core and perform the actual side effects. The article discusses the advantages (such as not having to deal with the sync vs. async dichotomy, and better testability) and also some disadvantages of this approach. </span></p>
++++

+++--+++

Thank you for reading!

//email: This newsletter is produced by Jakub Hol√Ω, a blogger and programming buddy / mentor for hire.
//email: If you don't want to receive it anymore, simple respond with "unsubscribe" in the subject

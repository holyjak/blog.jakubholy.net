{:title
 "What Changes When You Deploy More Frequently and Why You Should Do It",
 :date "2011-11-22",
 :layout :post,
 :tags ["opinion" "methodology" "DevOps"],
 :tags-orig
 ["agile" "continuous_deployment" "development" "DevOps" "opinion"],
 :categories ["General"],
 :extra-css #{}
}

++++
This post is inspired by Kent Beck's excellent talk at JavaZone 2011 titled <a href="https://vimeo.com/28803277">Software G Forces: The Effects of Acceleration</a> where he describes how the development process, practices and partly the whole organization change and/or have to change as you go from annual to monthly to weekly, daily, hourly deployments. I'd like to summarize some of the points he made and use that as a ground for arguing that more frequent deployments are (in general) better.<br><br>I'd highly recommend you to watch his presentation as I will only reproduce parts of it (and as they are out of their original context, they might well not represent exactly what Kent wanted to communicate).<br><br>Kent argues that as you deploy more and more frequently, many things have to change including the business side of the software. What is a best practice for one of these speeds becomes an impediment for another one. With more frequent deployments teams have to progress towards the following practices, while leaving some other practices behind:<br><br><!--more-->
<ul>
	<li>Better, more automated testing: developer testing, automated acceptance testing (a.k.a. <a href="https://specificationbyexample.com/">Specification by Example</a>). Notice that this implies that the software has to be designed for testability, which, I firmly believe, forces a better, more decoupled architecture (aside of the <a href="https://www.shino.de/2011/02/05/specification-by-example-the-big-win/">other benefits of well-done SbE</a>).</li>
	<li>Merging of QA/testing team and operations team with the development team. There may still be a testing specialist and an operations specialist but they are one team with a shared responsibility and commitment and everyone does a little of everything.</li>
	<li>Improved feedback about production use and state of the application. (Which makes f.ex. data-driven, i.e. experimentation-based instead of guess-driven usability [UI] design possible.)</li>
	<li>Automated deployments including support for rollback (and I'd also assume it becomes necessary to implement <a href="https://cacm.acm.org/blogs/blog-cacm/51564-extreme-agility-at-facebook/fulltext">gradual deployment</a> where functionality is first released to only a small subset of users and progressively enabled for more and more of them)</li>
	<li>Less up-front design and more empirical-based design refactoring and design evolution</li>
	<li>More suitable pricing model (per upgrade -&gt; subscription -&gt; per use ...)</li>
</ul>
As a developer I find a couple of things associated with more frequent deployments very attractive. The key terms are <em>rapid feedback</em> and <em>high quality</em>. Both of them are also cornerstones of the lean development -  you cannot go fast without achieving an excellent quality (as Mary Poppendieck argues in her <a href="https://www.pearsonhighered.com/educator/product/Implementing-Lean-Software-Development-From-Concept-to-Cash/9780321437389.page">book</a>) and feedback is much superior to guesswork in the complex world where we live and develop.<br><br>One of the positive changes is that the disconnection between developers and their application and its production life disappears. When programmers are isolated from the application by the QA and Ops teams they don't really care about how difficult it is to test or operate it. When they are one team, the communication becomes much better (=&gt; less wasted time) and the application will be much easier to test and operate (=&gt; yet less wasted time, less defects due to more effective testing and better defect detection). For me as a developer it is really a pain not to be a part of Ops and not to have a good insight into how my application is doing, how many people are using it and in which ways, how the latest new features have influenced this, and not to have a rapid defect detection and alerting (without them deployments become frightening ventures).<br><br>I very much agree with Kent that it is great to have daily+ deployments and rapid feedback from the production so that you can "feel the software" under your toes, meaning that whatever you decide now is going to effect users tomorrow. But it is not only about developers and feelings. As others have argued (just ask uncle Google about continuous delivery), more frequent deployments of small increments are much safer; good feedback makes it possible to detect and remove defects in virtually no time; it is cheaper (as I've reasoned above); and has many other benefits. Why then isn't everybody doing it? Well, radical changes aren't easy - and it isn't only the development that is transformed but the whole organization using the software. And it needs some effort to set up and some experience to do it correctly. So far continuous delivery is still a "new" paradigm and it will take time for the mainstream to understand and accept it.
<h2>Me On (Design) Refactoring</h2>
Frequent deployments make it possible to collect feedback and adjust the application correspondingly. Refactoring and <strong>design refactoring</strong> become an essential part of the process and replace the speculative design of today, that is designing for what you <em>think</em> - usually incorrectly - will be needed.<br><br>No matter how you make your design, the requirements will change and thus the design has to change too to prevent the software from turning into a growing pile of crap. Unfortunately too often people in the name of speed just cut corners and misuse and twist the old, insufficient design instead of reworking it, causing a lot of exponentially growing complexity and technical debt and thus a considerable loss.<br><br>Continuous, feedback-based design refactoring and evolution is the most reasonable and cost-effective approach to application design. Approach software development as continual improvement, as a <a href="https://www.stephenforte.net/PermaLink,guid,eb88ad5a-d7c1-48fd-8282-d2728e6464ad.aspx">kaizen event</a>.
<h2>Summary</h2>
The software development of the future will be an empirical process based on releasing often and adjusting based on the feedback. It requires higher process quality, removal of time wastes via efficient automation, removal of communication barriers between all stakeholders including testers and ops, and transformation of how the organization approaches software development, of its relations with customers, and of its business model. DevOps is a great model that can improve developer satisfaction and prevent a considerable waste.
<h2>Related Posts</h2>
<ul>
	<li>Greg Linden: <a href="https://cacm.acm.org/blogs/blog-cacm/40796-frequent-releases-change-software-engineering/fulltext">Frequent Releases Change Software Engineering</a></li>
	<li>(Norwegian) O. C. Rynning: <a href="https://open.bekk.no/felles-ansvar-for-produksjon/">Felles ansvar for produksjon!</a></li>
	<li>Aliastair Cockburn: <a href="https://alistair.cockburn.us/Trim+the+Tail">Design as knowledge creation</a> - the value of early feedback; also: "In most cases, the bigger the design that is done in the beginning, the more the unvalidated decisions produced, i.e. no “knowledge” is produced, only hypothesis, which is inventory."</li>
	<li>Regarding continuous system design refactoring - Aliastair Cockburn: <a href="https://alistair.cockburn.us/Incremental+Rearchitecture">Incremental Rearchitecture</a> - "Starting from a simple working architecture and applying Incremental Rearchitecture is a winning strategy for most, though not all systems" (Also provides guidelines for How completely designed should the system architecture and infrastructure be during the early stages of the project?)</li>
</ul>
<div class="linkscent-iconblock" style="float:none!important;border:0 solid #ff0000!important;background:none repeat scroll center center transparent!important;width:auto!important;height:auto!important;display:block!important;overflow:visible!important;position:static!important;text-indent:0!important;z-index:auto!important;max-width:none!important;min-width:0!important;max-height:none!important;min-height:0!important;left:auto!important;top:auto!important;bottom:auto!important;right:auto!important;line-height:16px!important;white-space:nowrap!important;margin:0!important;padding:0!important;"><img class="linkscent-icon" style="float:none!important;border:0 solid #ff0000!important;width:16px!important;height:16px!important;display:none;overflow:visible!important;position:absolute!important;text-indent:0!important;z-index:2147483635!important;max-width:none!important;min-width:0!important;max-height:none!important;min-height:0!important;left:580px;top:1199px;bottom:auto!important;right:auto!important;line-height:16px!important;white-space:nowrap!important;visibility:hidden;background:url('//interclue/content/cluecore/skins/default/linkscentExternal.png') no-repeat scroll center center transparent!important;opacity:0;margin:0;padding:0!important;" src="//interclue/content/cluecore/skins/default/pixel.gif" alt="" /><img class="linkscent-icon" style="float:none!important;border:0 solid #ff0000!important;background:none repeat scroll center center transparent;width:16px!important;height:16px!important;display:none;overflow:visible!important;position:absolute!important;text-indent:0!important;z-index:2147483635!important;max-width:none!important;min-width:0!important;max-height:none!important;min-height:0!important;left:598px;top:1199px;bottom:auto!important;right:auto!important;line-height:16px!important;white-space:nowrap!important;visibility:hidden;opacity:0;margin:0;padding:0!important;" src="//interclue/content/cluecore/skins/default/pixel.gif" alt="" /></div>

++++

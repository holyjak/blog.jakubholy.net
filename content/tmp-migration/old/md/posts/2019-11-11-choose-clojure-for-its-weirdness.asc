{:title "Choose Clojure not because it is easy but because it is \"`weird`\"", :tags ["clojure" "learning"], :category "SW Development", :toc true
}


When I was deciding what new language to learn, I could have picked the quite familiar Scala but chose instead Clojure - not _despite_ of its lack of object-orientation, its immutable data structures, its too many parentheses on a single line - but _because of_ it. (And because of Paul Graham’s http://www.paulgraham.com/avg.html[Beating the Averages].) Why?!

++++
<!--more-->
++++

(_Published originally at the https://engineering.telia.no/blog/choose-clojure-for-its-weirdness[Telia Engineering Blog]._)

When you find something easy to get started with it is mostly because it is somewhat familiar to you. Both Kotlin and Scala tout themselves as languages a Java developer can understand in a short while. The result is that you end up with "`Scaja`" - Java written in Scala source files. Yes, the developers will eventually learn and start using some of the new tools and start writing more idiomatic code. But they are still only adding somewhat better and more universal screw drivers to their set of screw drivers. If you really want to learn, you want to get out of your comfort bubble. You want something that challenges your thinking, habits, and patterns, something that doesn’t let you do the stuff you are used to do. You want something as different as possible, something that forces you to find new ways and approaches. As Peter Ralston writes in https://www.amazon.com/dp/B003WUYPOW/[The Book of Not Knowing: Exploring the True Nature of Self, Mind, and Consciousness] (p.65):

____
[..] it’s simply not possible to wonder, to truly question, unless we acknowledge that what we already know is not what we want to learn. In short, by definition, we want something unfamiliar to us, something new.
____

Therefore you should learn some Smalltalk to see a truly object-oriented language, its wonderful debugging capabilities, and the unusual https://en.wikipedia.org/wiki/Smalltalk#Image-based_persistence[state & code image] approach. You should learn something like Clojure, a Lisp with immutable data and really thought-through design and REPL-driven development. You should learn a truly statically typed language like Haskell (or perhaps PureScript or F#). Perhaps Erlang or Elixir to explore Erlang VM’s 100% uptime with live updates and a tree of supervised processes. The very same reasoning leads me to want to learn Rust over Go (a decision supported by the posts http://dtrace.org/blogs/bmc/2018/09/18/falling-in-love-with-rust/[Love Letter to Rust] and https://bluxte.net/musings/2018/04/10/go-good-bad-ugly/[Go: the Good, the Bad and the Ugly]).

We are speaking about learning here. You don’t need to master the languages, just learn enough to gain new insights and deeper understanding so that you can think better and write better software in whatever language you end up with. Yes, you still likely want to learn Python or C# or TypeScript to be able to find a job easily. But the insights, the ability to see problems from different points of view, and to see the benefits and limitations of your platform will serve you well. (But be warned - it might indeed happen to you, as it did to me, that you realize you don’t want to leave the new wonderful land you have been exploring and you will be forced to make your job so that you get to use the language :-).)

(Interestingly, I had to code some Lisp at my third year at a university. At that time, I knew too little to be able to appreciate and learn from its otherness. My brief encounter with Smalltalk two years later was much more valuable in this regard. And Haskell is still on my list, with few other languages… .)

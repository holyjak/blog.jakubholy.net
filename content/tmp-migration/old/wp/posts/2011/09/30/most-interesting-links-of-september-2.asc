{:title "Most interesting links of September",
 :date "2011-09-30",
 :layout :post,
 :tags ["testing" "clojure" "methodology" "refactoring" "quality"],
 :tags-orig
 ["agile" "CleanCode" "clojure" "lean" "refactoring" "scrum" "tdd"],
 :categories ["General" "Testing" "Top links of month"],
 :extra-css #{}
}

++++
<h2>Recommended Readings</h2>
<ul>
	<li><a href="https://martinfowler.com/articles/itsNotJustStandingUp.html">J. Yip: It's Not Just Standing Up: Patterns for Daily Standup Meetings</a> - it isn't easy to make stand-up meetings short, focused, energizing, and centered around continuous improvements and team spirit. This description of an example good standup, the meeting's goals, and especially the "patterns" and "bad smells" can be pretty useful to get and keep on the track towards a brighter future. TBD: standup goals: GIFTs, team spirit, appreciation where we go and are.</li>
	<li><a href="https://www.leanessays.com/2011/08/dont-separate-design-from.html">M. Poppendieck: Don’t Separate Design from Implementation</a> - according to Mary, (detailed) requirements - being it in the form of (backlog) user stories or any other - represent actually a design of the system, which shouldn't be done by the amateur product owner/business analyst but by professionals, meaning the developers, based on high-level goals and clear specification of the desired business value. She writes about a project that her factory outsourced and which she could have designed but didn't - yet it succeeded even though there were no detailed requirements. I've also read and unfortunately lost an interesting answer where the author argues that that is only possible if the developers are really experienced in the field. I tend to agree more with Mary though it is of course a question what "high" and "low" level goals/requirements are. But undeniably users/analysts tend to propose solutions disguised as requirements while often missing the technical insight to see possible other and better solutions. We also cannot expect the developers to produce a great SW if the true goals, needs, and business values behind the requested "features" aren't clearly communicated to them. (The best example - lost source again - is where a developer proposes to the client a simple process change that will solve the problem without writing a single line of code.)</li>
	<li>Mike Cohn: <a href="https://blog.mountaingoatsoftware.com/the-forgotten-layer-of-the-test-automation-pyramid">The Forgotten Layer of the Test Automation Pyramid</a> - three levels of testing with increasing number of tests: UI/Service/Unit (or end-to-end instead of UI), each requiring a different approach. Unit tests are best because a failure points directly to its source (with higher level tests you don't immediately know the cause). The higher in the pyramid, the less tests we should have (e.g. because of their redundancy). It's important not to forget the middle, service layer - unit tests are too low-level, UI tests too difficult and brittle. Also Gojko in Specification by Examples says that acceptance/BDD tests should run mainly at the service layer because of the UI level issues.
"Although automated unit testing is wonderful, it can cover only so much of an application’s testing needs. Without service-level testing to fill the gap between unit and user interface testing, all other testing ends up being performed through the user interface, resulting in tests that are <em>expensive to run, expensive to write, and brittle</em>." [Emphasis JH.]</li>
	<li><a href="https://pauldyson.wordpress.com/2011/08/15/technical-debt-and-the-lean-startup/">Technical Debt and the Lean Startup</a> - Paul Dyson remarks that while quality is an essential concern for projects in established environments, in the case of lean startups the primary goal is to find out whether a product is viable and what it should be like and thus it's reasonable to accept much higher technical debt by not spending too much time on ensuring scalability, de-duplication etc. - only when the product proves viable should we start to care for its long-evity by emphasizing the quality. But one thing can never miss and that is good test suite because this is the crucial factor that makes letter payment of the technical debt possible without ruining oneself.</li>
	<li><a href="https://johannesbrodwall.com/2011/06/22/real-time-coding-competition-with-extreme-startup/">Coding dojo - Real time coding competition with Extreme Startup</a> - an inspiring report about a coding dojo lead by Johannes Brodwall in Bergen's JUG, the task being the implementation of a server that can respond to questions send over HTTP (that's all participants know at the beginning - they learn the rest during the iterations)</li>
	<li><a href="https://blogs.lessthandot.com/index.php/ITProfessionals/ProfessionalDevelopment/using-code-katas-to-improve">Using Code Katas to Improve Programming Skills</a> - why to use code katas + links to different proposed katas</li>
	<li>Kent Beck: <a href="https://www.threeriversinstitute.org/blog/?p=594">Don’t Cross the Beams: Avoiding Interference Between Horizontal and Vertical Refactorings </a>- when to do depth-first (more exploratory) refactoring and when to extend it into breadth (i.e. apply it to several similar objects)</li>
</ul>
Learning Clojure (maybe not so interesting for those not learning the language)
<ul>
	<li>Phil Calçado: <a href="https://www.philcalcado.com/2011/08/29/my_experience_with_test/driven_development_in_clojure_and_functional_programming.html">My Experience With TDD In Clojure</a> (via planetclojure) - nice example of how to decompose a task in functional programming to make it easy to test (via Midje), including useful testing-related links and a discussion of side-effect isolation and the building blocks of functional programs, i.e. function composition using combinators (i.e. functions producing functions)</li>
	<li><a href="https://fronx.posterous.com/how-to-learn-clojure-effectively">How to learn Clojure effectively</a> (via planetclojure) - a very good description of how the task at  <a href="https://4clojure.com/">4Clojure</a> (though I prefer <a href="https://github.com/functional-koans/clojure-koans">Clojure koans</a>) should be solved to benefit one's learning the most plus some general tips on functional thinking</li>
	<li><a href="https://stackoverflow.com/questions/2444893/clojure-open-source-projects">Clojure open source projects</a> for learning how to code it</li>
</ul>
++++

{:title
 "Joshua Bloch: Performance Anxiety - on Performance Unpredictability, Its Measurement and Benchmarking",
 :date "2010-12-10",
 :layout :post,
 :tags ["java" "performance"],
 :tags-orig ["benchmarking" "java" "performance" "profiling"],
 :categories ["Languages"],
 :extra-css #{}
}

++++
Joshua Bloch had a great <a href="https://www.dzone.com/links/r/performance_anxiety_with_googles_josh_bloch.html">talk called Performance Anxiety</a> (30min, via Parleys; <a title="PerformanceAnxiety2010.pdf" href="https://wiki.jvmlangsummit.com/images/1/1d/PerformanceAnxiety2010.pdf">slides</a> also available ) at Devoxx 2010, the main message as I read it was
<ol>
	<li>Nowadays, performance is completely non-predictable. You have to measure it and employ proper statistics to get some meaningful results.</li>
	<li>Microbenchmarking is very, very hard to do correctly. No, you misunderstand me, I mean even harder than that! :-)</li>
	<li>From the resources: Profiles and result evaluation methods may be very misleading unless used correctly.</li>
</ol>
<!--more-->There have been <a href="https://www.frogcake.net/blog/2010/11/17/devoxx-performance-anxiety">another blog about it</a> but I'd like to record here more detailed remarks.<br><br>Today we can't estimate performance, we must measure it because the systems (JVM, OS, processor, ...) are very complex with many different heuristics on various levels and thus the <strong>performance is highly unpredictable</strong>. This doesn't apply only to Java, but also to C, C++, even to assembly code.<br><br><strong>Example</strong>: Results during a single JVM run may be consistent (warm-up, then faster) but can vary between JVM executions even by 20%. One of the causes may be Compilation Planning (what's inlined, ...) - it's done in a background thread and thus is inherently non-deterministic.<br><br>Therefore <strong>don't estimate but measure</strong> and not only that - also do <strong>statistical processing</strong> of the data (how often diff. values appear, what they are, ... - mean, median, standard deviation etc.).<br><br>"<strong>Profiles don't help much</strong>; in fact, they can mislead" - Mytkowicz, Diwan etc. - <a rel="nofollow" href="https://www-plan.cs.colorado.edu/klipto/mytkowicz-pldi10.pdf">"Evaluating the Accuracy of Java Proﬁlers"</a>, PLDI '10 - in their experiment, each of 4 leading profiles identified a different hotspot. I'd really recommend you reading the related <a href="https://stackoverflow.com/questions/4387895/if-profiler-is-not-the-answer-what-other-choices-do-we-have">StackOverflow discussion "If profiler is not the answer, what other choices do we have?"</a> (the answer is: profilers have their value, but use the correct ones and use them correctly). The conclusion of the original paper:
<blockquote>Our results are disturbing because they indicate that proﬁler  incorrectness is pervasive—occurring in most of our seven benchmarks and  in two production JVM—-and signiﬁcant—all four of   the state-of-the-art proﬁlers produce incorrect proﬁles. Incorrect   proﬁles can easily cause a performance analyst to spend time  optimizing cold methods that will have minimal effect on performance.   We show that a proof-of-concept proﬁler that does not use yield   points for sampling does not suffer from the above problems.</blockquote>
"Benchmarking is really, really hard!" and "<strong>Most benchmarks are seriously broken</strong>". Broken means that either the measurement's error is higher than the value being measured or that the results obtained are unrelated to intended measurements. It seems that it is actually really hard to find a (micro)-benchmark, which isn't broken. Joshua recommends Cliff Click's JavaOne 2009 presentation <a href="https://developers.sun.com/learning/javaoneonline/sessions/2009/pdf/TS-5391.pdf">The Art of (Java) Benchmarking</a> (see also an interesting <a href="https://java.sun.com/javaone/2009/articles/rockstar_click.jsp">related interview</a> with Cliff), which I belive to have seen and which points out the various traps here. Joshu also mentiones that some frameworks, such as <a href="https://code.google.com/p/caliper/">Google Caliper</a> may help you to avoid the pitfalls, though I'm quite sure they can't protect you from all.<br><br>Joshua mentiones a couple of <strong>interesting papers</strong>, you should check the <a title="PerformanceAnxiety2010.pdf" href="https://wiki.jvmlangsummit.com/images/1/1d/PerformanceAnxiety2010.pdf">slides</a> for them. One which sounds really interesting to me is by Georges, Buytaert and Eeckhout - <a href="https://itkovian.net/base/files/papers/oopsla2007-georges-preprint.pdf">Statistically Rigorous Java Performance Evaluation</a>, OOPSLA07 (20 pages). They mention there that you need to run VM 30 times to get meaningful data. From the <a href="https://www.itkovian.net/base/statistically-rigorous-java-performance-evaluation/">abstract</a>:
<blockquote>This paper shows that prevalent methodologies can be misleading, and can  even lead to incorrect conclusions. The reason is that the data  analysis is not statistically rigorous. In this paper, we present a  survey of existing Java performance evaluation methodologies and discuss  the importance of statistically rigorous data analysis for dealing with  non-determinism. We advocate approaches to quantify startup as well as  steady-state performance, and, in addition, we provide the JavaStats  software to automatically obtain performance numbers in a rigorous  manner. Although this paper focuses on Java performance evaluation, many  of the issues addressed in this paper also apply to other programming  languages and systems that build on a managed runtime system.</blockquote>
<h2>Personal touch</h2>
I find this subject very interesting because for over a year I'm involved in performance optimization of one of our data feeds, which used to run for couple of days (latest results: 1/2h [with a bit of cheating]). My experience completely supports what Joshua says - don't guess but measure, profilers may be misleading, performance is unpredictable. Though as a collegue mentioned, in the domain of enterprise Java, our performance problems are usually caused by the database and communication with it (which 100% applies to that feed too).<br><br>I've already blogged about some experiences, e.g. in <a href="/2010/09/20/the-power-of-batching-or-speeding-jdbc-by-100/">The power of batching or speeding JDBC by 100</a> (inspired by <a href="https://www.dzone.com/links/r/jdbc_performance_tuning_with_fetch_size.html">JDBC performance tuning with fetch size</a>), check also the <a href="/tag/performance/">performance tag</a> for interesting links. I also appreciated and applied the knowledge from <a href="https://www.johndcook.com/standard_deviation.html">Accurately computing running variance</a> (I often wish I have slept less and paid attention more during the uni math lectures :-)).
<h2>Conclusion</h2>
The higher complexity, the higher unpredictability =&gt;
<ul>
	<li>As an application programmer, use high-level, declarative constructs where posible to push the responsability for performance one level down to library and JVM authors, who should know better.</li>
	<li>Measure repeatedly and process the results with proper statistics. Don't forget to repeat them over time, the platform evolves with every release.</li>
</ul>
Once again, microbenchmarking is hard! :-) If you have to play with it, use something like Caliper and be aware that your results are most likely wrong anyway.<br><br>Closing words: Merry Christmas!
++++

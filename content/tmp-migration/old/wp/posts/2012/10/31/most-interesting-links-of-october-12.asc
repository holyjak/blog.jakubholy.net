{:title "Most interesting links of October '12",
 :date "2012-10-31",
 :layout :post,
 :tags ["scala" "clojure" "java" "legacy" "productivity" "quality"],
 :tags-orig
 ["bash" "clojure" "java" "legacy" "productivity" "quality" "scala"],
 :categories
 ["General" "Languages" "Testing" "Tools" "Top links of month"],
 :extra-css #{}
}

++++
<h2>Recommended Readings</h2>
<ul>
	<li><a href="https://automagical.rationalmind.net/2010/08/17/some-lesser-known-truths-about-programming/">David Veksler: Some lesser-known truths about programming</a> - things newcomers into the field of IT don't know and don't expect, true and an interesting read. Not backed by good data but anyway. F.ex.: "[..] a programmer spends about 10-20% of his time writing code [..] much of the other 90% thinking, researching, and experimenting". "A good programmer is ten times more productive than an average programmer. A great programmer is 20-100 times more productive than the average [..]" "Bad programmers write code which lacks conceptual integrity, non-redundancy, hierarchy, and patterns, and so is very difficult to refactor." "Continuous change leads to software rot, which erodes the conceptual integrity of the original design." "A <a href="https://www.softwaremag.com/focus-areas/application-development/product-coverage/standish-project-success-rates-improved-over-10-years/">2004 study found that</a> most software projects (51%) will fail in a critical aspect, and 15% will fail totally."</li>
	<li>Brett L. Schuchert: <a href="https://martinfowler.com/articles/modernMockingTools.html">Modern Mocking Tools and Black Magic - An example of power corrupting</a> - interesting for two reasons: a good analysis of a poorly written piece of code and discussion of the code injection black magic (<a href="https://code.google.com/p/jmockit/">JMockIt</a>) vs. actually breaking dependencies to enable tests.  The author presents a typical example of low-quality method (mixing multiple concerns, mixing different levels of abstractions, untestable due to a hardcoded use of an external call) and discusses ways to improve it and to make it testable. Recommended to read.</li>
	<li><a href="https://pragprog.com/magazines/2012-10/its-not-about-the-unit-tests">It’s Not About the Unit Tests - Learning from iOS Developers</a>: iOS developers don't do much testing yet they manage to produce high quality. How is that possible? The key isn't testing itself, but caring for the code. (Of course, iOS is little special: small apps, no legacy, a powerful platform that does lot for the apps, very visual apps.) "It’s not about the practices. It’s about the spirit and intent behind them, and how they are applied." (M. Fowler had a similar observation about a team that used mock-based testing exclusively and thus lacked integration tests yet all worked. [I've lost the link to the post and would be grateful for it])</li>
	<li><a href="https://www.javacodegeeks.com/2012/10/java-code-quality-tools-overview.html">Java Code Quality Tools – Overview</a> - brief descriptions of 44 quality-related tools including some interesting tools and Eclipse plugins I didn't know or knew but forgot. F.ex. analysis of dependencies with <a href="https://www.jboss.org/tattletale">JBoss Tattletale</a> or <a href="https://www.kirkk.com/main/Main/JarAnalyzer">JarAnalyzer</a>, <a href="https://clirr.sourceforge.net/">Clirr</a> to check libraries for source and binary backwards compatibility, <a href="https://jdiff.sourceforge.net/">JDiff</a> generates JavaDoc-based report of removed/added/changed in an API. <a href="https://spoon.gforge.inria.fr/">Spoon</a> - read and check or transform Java code. <a href="https://babelfish.arc.nasa.gov/trac/jpf">Java PathFinder</a> (NASA) - special JVM capable of checking all execution path to discover concurrency defects etc.</li>
</ul>
<h2>Tools</h2>
<ul>
	<li><a href="https://www.linuxjournal.com/article/10585?page=0,0">DirB, Directory Bookmarks for Bash</a> (<a href="https://www.dirb.info/">home</a>) - moving efficiently among favourite directories (<code>s &lt;name&gt;</code> to create a bookmark for pwd, <code>g &lt;bookmark | relative/abs dir path&gt;</code> to enter a dir (=&gt; works both for bookmarks and as a replacement for cd); also support for relative path bookmarks &amp; more; <code>sl</code> lists bookmakrs in the last used order) (You might also want to check out <a href="https://jakemccrary.com/blog/2011/07/25/utilities-i-like-autojump/">Autojump</a>, <a href="/2011/12/31/most-interesting-links-of-december-2/">described in Dec 11</a>; <a href="https://www.huyng.com/projects/bashmarks/">bashmarks</a> is another similar project. Another similar project is rupa's <a href="https://github.com/rupa/z">z</a> and <a href="https://github.com/rupa/j2">j2</a> and the fish clone <a href="https://github.com/sjl/z-fish">z-fish</a>)</li>
</ul>
<h2>Clojure Corner</h2>
<ul>
	<li> Jon Pither: <a href="https://www.pitheringabout.com/?p=693">Clojure at a Bank – Moving from Java</a> -  the justification (productivity, dynamism, FP a better match for the domain) and process behind moving from Java to Clojure with a monolithic 1M LOC Spring/Hibernate app. (Random quotes: "I had used some dynamical languages before and it was quite obvious that we were essentially forcing lots of schema and type definition on to a problem domain that just didn’t want or need it." "[..] it [dependency injection] just looks redundant in retrospect now that I’m working 95% with FP code.") There is also a EuroClojure <a href="https://vimeo.com/45130708">talk about their experiences</a> one year later (35 min).</li>
	<li><a href="https://blog.getprismatic.com/blog/2012/10/1/prismatics-graph-at-strange-loop.html">Prismatic's "Graph" at Strange Loop</a> - an interesting desing problem, its solution, and a resulting OSS library. The problem: How to break a large function into independently usable small ones that might depend on each other without ever needing to recompute a value once the function producing is called. The solution: Graph - "Graph is a <em>simple</em>, <em>declarative</em> abstraction to express compositional structure." (Enabling explicit declaration of data dependencies and pluging in different implementations.)</li>
	<li>The Oblong: Blog about 2/3 D <a href="https://oblong-code.blogspot.no/">game programming in Clojure</a>, starting from scratch (w/o an engine); interesting experiences</li>
	<li><a href="https://clojurefun.wordpress.com/2012/09/03/ironclad-steam-legions-clojure-game-development-battle-report/">Ironclad: Steam Legions – Clojure game development battle report</a> (the game <a href="https://github.com/mikera/ironclad">on Github</a>)</li>
	<li><a href="https://variadic.me/posts/2012-03-29-building-wishlisted.html">Building the Wishlisted.org webapp in Clojure</a> - experiences from learning Clojure for real by building a webapp in Noir</li>
	<li><a href="https://blog.markwatson.com/2012/10/clojure-vs-scala-smackdown.html">Clojure vs. Scala smackdown</a> ("Just kidding with the title of this post :-)") - a short post with interesting discussion. Dmitri Sotnikov's opinion resonates with me: "I found that for me Clojure wins on simplicity and consistency. While it looks more alien initially, once you learn the basics, you just reuse the same patterns everywhere." Some more comments: "One major concern was maintainability, since it's fairly easy to write very dense code. This turned out to not be a problem in practice. Because Clojure code is written as a tree, refactoring it is very easy." REPL seems to be a big win (applies to Scala too). Scala's type system might get tedious and learning its quirks takes time but there is lot of potential and both have they strong sides.</li>
	<li><a href="https://www.colourcoding.net/blog/archive/2012/10/15/code-fatigue.aspx">Code Fatigue</a> - discussion of the advantages of learning, using, and combining the (many) standard Clojure functions instead of a "basic solution" using recursion etc. The argument is in favor of higher-level code with less complexity in the form of branching, recursion, nested expressions etc. and thus less mental fatigue.</li>
</ul>
<h2>Favorite Quotes</h2>
<blockquote>A classic test only cares about the final state - not how that state was derived. Mockist tests are thus <em>more coupled to the implementation</em> [emphasis mine] of a method. Changing the nature of calls to collaborators usually cause a mockist test to break.<br><br><em>- Martin Fowler in his classical <a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks Aren't Stubs</a></em></blockquote>
I'm afraid of code. When I see a big pile of code, I get scared ;-). Some classes and method make me cry. I had troubles explaining why I prefer short pieces of code keeping the same level of abstraction, cohesive and loosely coupled. The following quote captures the essence - improved communication.
<blockquote>One way to improve communication is to reduce the need for it and the same can be said for code. [...] Since we tend to read code more than write it, anything we can do to reduce the need to read code is time well invested in the life of a project.<br><br>- Brett L. Schuchert in <a href="https://martinfowler.com/articles/modernMockingTools.html">Modern Mocking Tools and Black Magic - An example of power corrupting</a> justifying extraction of code into another class or method</blockquote>
++++
